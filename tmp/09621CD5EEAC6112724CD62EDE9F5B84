
   // Use @Override to avoid accidental overloading.
   &#x0040;Override public boolean equals(Object o) {
     // Return true if the objects are identical.
     // (This is just an optimization, not required for correctness.)
     if (this == o) {
       return true;
     }

     // Return false if the other object has the wrong type.
     // This type may be an interface depending on the interface's specification.
     if (!(o instanceof MyType)) {
       return false;
     }

     // Cast to the appropriate type.
     // This will succeed because of the instanceof, and lets us access private fields.
     MyType lhs = (MyType) o;

     // Check each field. Primitive fields, reference fields, and nullable reference
     // fields are all treated differently.
     return primitiveField == lhs.primitiveField &&
             referenceField.equals(lhs.referenceField) &&
             (nullableField == null ? lhs.nullableField == null
                                    : nullableField.equals(lhs.nullableField));
   }
 