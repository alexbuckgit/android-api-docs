<Type Name="ISerializable" FullName="Java.IO.ISerializable">
  <TypeSignature Language="C#" Value="public interface ISerializable : Android.Runtime.IJavaObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ISerializable implements class Android.Runtime.IJavaObject, class System.IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>Android.Runtime.IJavaObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("java/io/Serializable", "", "Java.IO.ISerializableInvoker")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Marks classes that can be serialized by <c><see cref="T:Java.IO.ObjectOutputStream" /></c> and
 deserialized by <c><see cref="T:Java.IO.ObjectInputStream" /></c>.</summary>
    <remarks>
      <para tool="javadoc-to-mdoc">Marks classes that can be serialized by <c><see cref="T:Java.IO.ObjectOutputStream" /></c> and
 deserialized by <c><see cref="T:Java.IO.ObjectInputStream" /></c>.

 </para>
      <para tool="javadoc-to-mdoc">
        <i>Warning:</i> this interface limits how its implementing
 classes can change in the future. By implementing <c>Serializable</c> you
 expose your flexible in-memory implementation details as a rigid binary
 representation. Simple code changes--like renaming private fields--are
 not safe when the changed class is serializable.

 <format type="text/html"><h3>The Serialized Form</h3></format>
 By default, the serialization mechanism encodes an object's class name, the
 names of its non-transient fields (including non-public fields), and the
 values of all of those fields. The output is an opaque sequence of bytes.
 Those bytes can be decoded into a new, equivalent instance as long as the
 decoder has compatible versions of the originating classes.

 </para>
      <para tool="javadoc-to-mdoc">Changing the class name, field names or field types breaks serialization
 compatibility and complicates interoperability between old and new versions
 of the serializable class. Adding or removing fields also complicates
 serialization between versions of a class because it requires your code to
 cope with missing fields.

 </para>
      <para tool="javadoc-to-mdoc">Every serializable class is assigned a version identifier called a <c>serialVersionUID</c>. By default, this identifier is computed by hashing the
 class declaration and its members. This identifier is included in the
 serialized form so that version conflicts can be detected during
 deserialization. If the local <c>serialVersionUID</c> differs from the
 <c>serialVersionUID</c> in the serialized data, deserialization will fail
 with an <c><see cref="T:Java.IO.InvalidClassException" /></c>.

 </para>
      <para tool="javadoc-to-mdoc">You can avoid this failure by declaring an explicit <c>serialVersionUID</c>. Declaring an explicit <c>serialVersionUID</c> tells the
 serialization mechanism that the class is forward and backward compatible
 with all versions that share that <c>serialVersionUID</c>. Declaring a
 <c>serialVersionUID</c> looks like this: <sample external-id="AD4EF5ED6FD03560A9EA1B79F961663A" />
 If you declare a <c>serialVersionUID</c>, you should increment it each
 time your class changes incompatibly with the previous version. Typically
 this is when you add, change or remove a non-transient field.

 </para>
      <para tool="javadoc-to-mdoc">You can take control of your serialized form by implementing these two
 methods with these exact signatures in your serializable classes:
 <sample external-id="4DBDC1855EB5401CE1808609A850296F" />
 It is impossible to maintain serialization compatibility across a class name
 change. For this reason, implementing <c>Serializable</c> in anonymous
 inner classes is highly discouraged: simply reordering the members in the
 file could change the generated class name and break serialization
 compatibility.

 </para>
      <para tool="javadoc-to-mdoc">You can exclude member fields from serialization by giving them the <c>transient</c> modifier. Upon deserialization, the transient field's value will
 be null, 0, or false according to its type.

 <format type="text/html"><h3>Implement Serializable Judiciously</h3></format>
 Refer to <format type="text/html"><i>Effective Java</i></format>'s chapter on serialization for thorough
 coverage of the serialization API. The book explains how to use this
 interface without harming your application's maintainability.

 <format type="text/html"><h3>Recommended Alternatives</h3></format><i>JSON</i> is concise, human-readable and efficient. Android
 includes both a <c><see cref="T:Android.Util.JsonReader" /></c> and a <c><see cref="T:Org.Json.JSONObject" /></c> to read and write JSON. Use a binding library
 like  to read and
 write Java objects directly.
</para>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <a href="http://developer.android.com/reference/java/io/Serializable.html" target="_blank">[Android Documentation]</a>
        </format>
      </para>
    </remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members />
</Type>
