<Type Name="ICondition" FullName="Java.Util.Concurrent.Locks.ICondition">
  <TypeSignature Language="C#" Value="public interface ICondition : Android.Runtime.IJavaObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract ICondition implements class Android.Runtime.IJavaObject, class System.IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>Android.Runtime.IJavaObject</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("java/util/concurrent/locks/Condition", "", "Java.Util.Concurrent.Locks.IConditionInvoker")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><c>Condition</c> factors out the <c>Object</c> monitor
 methods (<c><see cref="M:Java.Lang.Object.Wait" /></c>, <c><see cref="M:Java.Lang.Object.Notify" /></c>
 and <c><see cref="M:Java.Lang.Object.NotifyAll" /></c>) into distinct objects to
 give the effect of having multiple wait-sets per object, by
 combining them with the use of arbitrary <c><see cref="T:Java.Util.Concurrent.Locks.ILock" /></c> implementations.</summary>
    <remarks><para tool="javadoc-to-mdoc"><c>Condition</c> factors out the <c>Object</c> monitor
 methods (<c><see cref="M:Java.Lang.Object.Wait" /></c>, <c><see cref="M:Java.Lang.Object.Notify" /></c>
 and <c><see cref="M:Java.Lang.Object.NotifyAll" /></c>) into distinct objects to
 give the effect of having multiple wait-sets per object, by
 combining them with the use of arbitrary <c><see cref="T:Java.Util.Concurrent.Locks.ILock" /></c> implementations.
 Where a <c>Lock</c> replaces the use of <c>synchronized</c> methods
 and statements, a <c>Condition</c> replaces the use of the Object
 monitor methods.

 </para><para tool="javadoc-to-mdoc">Conditions (also known as <i>condition queues</i> or
 <i>condition variables</i>) provide a means for one thread to
 suspend execution (to "wait") until notified by another
 thread that some state condition may now be true.  Because access
 to this shared state information occurs in different threads, it
 must be protected, so a lock of some form is associated with the
 condition. The key property that waiting for a condition provides
 is that it <i>atomically</i> releases the associated lock and
 suspends the current thread, just like <c>Object.wait</c>.

 </para><para tool="javadoc-to-mdoc">A <c>Condition</c> instance is intrinsically bound to a lock.
 To obtain a <c>Condition</c> instance for a particular <c><see cref="T:Java.Util.Concurrent.Locks.ILock" /></c>
 instance use its <c><see cref="M:Java.Util.Concurrent.Locks.ILock.NewCondition" /></c> method.

 </para><para tool="javadoc-to-mdoc">As an example, suppose we have a bounded buffer which supports
 <c>put</c> and <c>take</c> methods.  If a
 <c>take</c> is attempted on an empty buffer, then the thread will block
 until an item becomes available; if a <c>put</c> is attempted on a
 full buffer, then the thread will block until a space becomes available.
 We would like to keep waiting <c>put</c> threads and <c>take</c>
 threads in separate wait-sets so that we can use the optimization of
 only notifying a single thread at a time when items or spaces become
 available in the buffer. This can be achieved using two
 <c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c> instances.
 <example><code lang="java">
 class BoundedBuffer {
   final Lock lock = new ReentrantLock();
   final Condition notFull  = lock.newCondition(); 
   final Condition notEmpty = lock.newCondition(); 

   final Object[] items = new Object[100];
   int putptr, takeptr, count;

   public void put(Object x) throws InterruptedException {
     lock.lock();
     try {
       while (count == items.length)
         notFull.await();
       items[putptr] = x;
       if (++putptr == items.length) putptr = 0;
       ++count;
       notEmpty.signal();} finally {
       lock.unlock();
     }
   }

   public Object take() throws InterruptedException {
     lock.lock();
     try {
       while (count == 0)
         notEmpty.await();
       Object x = items[takeptr];
       if (++takeptr == items.length) takeptr = 0;
       --count;
       notFull.signal();
       return x;
     } finally {
       lock.unlock();
     }
   }
 }
 </code></example>

 (The <c><see cref="T:Java.Util.Concurrent.ArrayBlockingQueue" /></c> class provides
 this functionality, so there is no reason to implement this
 sample usage class.)

 </para><para tool="javadoc-to-mdoc">A <c>Condition</c> implementation can provide behavior and semantics
 that is
 different from that of the <c>Object</c> monitor methods, such as
 guaranteed ordering for notifications, or not requiring a lock to be held
 when performing notifications.
 If an implementation provides such specialized semantics then the
 implementation must document those semantics.

 </para><para tool="javadoc-to-mdoc">Note that <c>Condition</c> instances are just normal objects and can
 themselves be used as the target in a <c>synchronized</c> statement,
 and can have their own monitor <c><see cref="M:Java.Lang.Object.Wait" /></c> and
 <c><see cref="M:Java.Lang.Object.Notify" /></c> methods invoked.
 Acquiring the monitor lock of a <c>Condition</c> instance, or using its
 monitor methods, has no specified relationship with acquiring the
 <c><see cref="T:Java.Util.Concurrent.Locks.ILock" /></c> associated with that <c>Condition</c> or the use of its
 <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.Await" /></c> and <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.Signal" /></c> methods.
 It is recommended that to avoid confusion you never use <c>Condition</c>
 instances in this way, except perhaps within their own implementation.

 </para><para tool="javadoc-to-mdoc">Except where noted, passing a <c>null</c> value for any parameter
 will result in a <c><see cref="T:Java.Lang.NullPointerException" /></c> being thrown.

 <format type="text/html"><h3>Implementation Considerations</h3></format></para><para tool="javadoc-to-mdoc">When waiting upon a <c>Condition</c>, a "<i>spurious
 wakeup</i>" is permitted to occur, in
 general, as a concession to the underlying platform semantics.
 This has little practical impact on most application programs as a
 <c>Condition</c> should always be waited upon in a loop, testing
 the state predicate that is being waited for.  An implementation is
 free to remove the possibility of spurious wakeups but it is
 recommended that applications programmers always assume that they can
 occur and so always wait in a loop.

 </para><para tool="javadoc-to-mdoc">The three forms of condition waiting
 (interruptible, non-interruptible, and timed) may differ in their ease of
 implementation on some platforms and in their performance characteristics.
 In particular, it may be difficult to provide these features and maintain
 specific semantics such as ordering guarantees.
 Further, the ability to interrupt the actual suspension of the thread may
 not always be feasible to implement on all platforms.

 </para><para tool="javadoc-to-mdoc">Consequently, an implementation is not required to define exactly the
 same guarantees or semantics for all three forms of waiting, nor is it
 required to support interruption of the actual suspension of the thread.

 </para><para tool="javadoc-to-mdoc">An implementation is required to
 clearly document the semantics and guarantees provided by each of the
 waiting methods, and when an implementation does support interruption of
 thread suspension then it must obey the interruption semantics as defined
 in this interface.

 </para><para tool="javadoc-to-mdoc">As interruption generally implies cancellation, and checks for
 interruption are often infrequent, an implementation can favor responding
 to an interrupt over normal method return. This is true even if it can be
 shown that the interrupt occurred after another action that may have
 unblocked the thread. An implementation should document this behavior.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/Condition.html" target="_blank">[Android Documentation]</a></format></para></remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members>
    <Member MemberName="Await">
      <MemberSignature Language="C#" Value="public void Await ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Await() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("await", "()V", "GetAwaitHandler:Java.Util.Concurrent.Locks.IConditionInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes the current thread to wait until it is signalled or
 <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>.</summary>
        <remarks><para tool="javadoc-to-mdoc">Causes the current thread to wait until it is signalled or
 <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>.

 </para><para tool="javadoc-to-mdoc">The lock associated with this <c>Condition</c> is atomically
 released and the current thread becomes disabled for thread scheduling
 purposes and lies dormant until <i>one</i> of four things happens:
 <list type="bullet"><item><term>Some other thread invokes the <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.Signal" /></c> method for this
 <c>Condition</c> and the current thread happens to be chosen as the
 thread to be awakened; or
 </term></item><item><term>Some other thread invokes the <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.SignalAll" /></c> method for this
 <c>Condition</c>; or
 </term></item><item><term>Some other thread <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> the
 current thread, and interruption of thread suspension is supported; or
 </term></item><item><term>A "<i>spurious wakeup</i>" occurs.
 </term></item></list></para><para tool="javadoc-to-mdoc">In all cases, before this method can return the current thread must
 re-acquire the lock associated with this condition. When the
 thread returns it is <i>guaranteed</i> to hold this lock.

 </para><para tool="javadoc-to-mdoc">If the current thread:
 <list type="bullet"><item><term>has its interrupted status set on entry to this method; or
 </term></item><item><term>is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> while waiting
 and interruption of thread suspension is supported,
 </term></item></list>
 then <c><see cref="T:Java.Lang.InterruptedException" /></c> is thrown and the current thread's
 interrupted status is cleared. It is not specified, in the first
 case, whether or not the test for interruption occurs before the lock
 is released.

 </para><para tool="javadoc-to-mdoc"><format type="text/html"><b>Implementation Considerations</b></format></para><para tool="javadoc-to-mdoc">The current thread is assumed to hold the lock associated with this
 <c>Condition</c> when this method is called.
 It is up to the implementation to determine if this is
 the case and if not, how to respond. Typically, an exception will be
 thrown (such as <c><see cref="T:Java.Lang.IllegalMonitorStateException" /></c>) and the
 implementation must document that fact.

 </para><para tool="javadoc-to-mdoc">An implementation can favor responding to an interrupt over normal
 method return in response to a signal. In that case the implementation
 must ensure that the signal is redirected to another waiting thread, if
 there is one.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/Condition.html#await()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.InterruptedException">if the current thread is interrupted
         (and interruption of thread suspension is supported)
</exception>
      </Docs>
    </Member>
    <Member MemberName="Await">
      <MemberSignature Language="C#" Value="public bool Await (long time, Java.Util.Concurrent.TimeUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Await(int64 time, class Java.Util.Concurrent.TimeUnit unit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("await", "(JLjava/util/concurrent/TimeUnit;)Z", "GetAwait_JLjava_util_concurrent_TimeUnit_Handler:Java.Util.Concurrent.Locks.IConditionInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="time" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
      </Parameters>
      <Docs>
        <param name="time">the maximum time to wait</param>
        <param name="unit">the time unit of the <c>time</c> argument</param>
        <summary>Causes the current thread to wait until it is signalled or interrupted,
 or the specified waiting time elapses.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Causes the current thread to wait until it is signalled or interrupted,
 or the specified waiting time elapses. This method is behaviorally
 equivalent to:
  <example><code lang="java">awaitNanos(unit.toNanos(time)) &gt; 0</code></example></para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/Condition.html#await(long, java.util.concurrent.TimeUnit)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.InterruptedException">if the current thread is interrupted
         (and interruption of thread suspension is supported)
</exception>
      </Docs>
    </Member>
    <Member MemberName="AwaitNanos">
      <MemberSignature Language="C#" Value="public long AwaitNanos (long nanosTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 AwaitNanos(int64 nanosTimeout) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("awaitNanos", "(J)J", "GetAwaitNanos_JHandler:Java.Util.Concurrent.Locks.IConditionInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nanosTimeout" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="nanosTimeout">the maximum time to wait, in nanoseconds</param>
        <summary>Causes the current thread to wait until it is signalled or interrupted,
 or the specified waiting time elapses.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Causes the current thread to wait until it is signalled or interrupted,
 or the specified waiting time elapses.

 </para><para tool="javadoc-to-mdoc">The lock associated with this condition is atomically
 released and the current thread becomes disabled for thread scheduling
 purposes and lies dormant until <i>one</i> of five things happens:
 <list type="bullet"><item><term>Some other thread invokes the <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.Signal" /></c> method for this
 <c>Condition</c> and the current thread happens to be chosen as the
 thread to be awakened; or
 </term></item><item><term>Some other thread invokes the <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.SignalAll" /></c> method for this
 <c>Condition</c>; or
 </term></item><item><term>Some other thread <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> the
 current thread, and interruption of thread suspension is supported; or
 </term></item><item><term>The specified waiting time elapses; or
 </term></item><item><term>A "<i>spurious wakeup</i>" occurs.
 </term></item></list></para><para tool="javadoc-to-mdoc">In all cases, before this method can return the current thread must
 re-acquire the lock associated with this condition. When the
 thread returns it is <i>guaranteed</i> to hold this lock.

 </para><para tool="javadoc-to-mdoc">If the current thread:
 <list type="bullet"><item><term>has its interrupted status set on entry to this method; or
 </term></item><item><term>is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> while waiting
 and interruption of thread suspension is supported,
 </term></item></list>
 then <c><see cref="T:Java.Lang.InterruptedException" /></c> is thrown and the current thread's
 interrupted status is cleared. It is not specified, in the first
 case, whether or not the test for interruption occurs before the lock
 is released.

 </para><para tool="javadoc-to-mdoc">The method returns an estimate of the number of nanoseconds
 remaining to wait given the supplied <c>nanosTimeout</c>
 value upon return, or a value less than or equal to zero if it
 timed out. This value can be used to determine whether and how
 long to re-wait in cases where the wait returns but an awaited
 condition still does not hold. Typical uses of this method take
 the following form:

  <example><code lang="java">boolean aMethod(long timeout, TimeUnit unit) {
   long nanos = unit.toNanos(timeout);
   lock.lock();
   try {
     while (!conditionBeingWaitedFor()) {
       if (nanos &lt;= 0L)
         return false;
       nanos = theCondition.awaitNanos(nanos);
     
     // ...
   } finally {
     lock.unlock();
   }
 }}</code></example></para><para tool="javadoc-to-mdoc">Design note: This method requires a nanosecond argument so
 as to avoid truncation errors in reporting remaining times.
 Such precision loss would make it difficult for programmers to
 ensure that total waiting times are not systematically shorter
 than specified when re-waits occur.

 </para><para tool="javadoc-to-mdoc"><format type="text/html"><b>Implementation Considerations</b></format></para><para tool="javadoc-to-mdoc">The current thread is assumed to hold the lock associated with this
 <c>Condition</c> when this method is called.
 It is up to the implementation to determine if this is
 the case and if not, how to respond. Typically, an exception will be
 thrown (such as <c><see cref="T:Java.Lang.IllegalMonitorStateException" /></c>) and the
 implementation must document that fact.

 </para><para tool="javadoc-to-mdoc">An implementation can favor responding to an interrupt over normal
 method return in response to a signal, or over indicating the elapse
 of the specified waiting time. In either case the implementation
 must ensure that the signal is redirected to another waiting thread, if
 there is one.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/Condition.html#awaitNanos(long)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.InterruptedException">if the current thread is interrupted
         (and interruption of thread suspension is supported)
</exception>
      </Docs>
    </Member>
    <Member MemberName="AwaitUninterruptibly">
      <MemberSignature Language="C#" Value="public void AwaitUninterruptibly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AwaitUninterruptibly() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("awaitUninterruptibly", "()V", "GetAwaitUninterruptiblyHandler:Java.Util.Concurrent.Locks.IConditionInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes the current thread to wait until it is signalled.</summary>
        <remarks><para tool="javadoc-to-mdoc">Causes the current thread to wait until it is signalled.

 </para><para tool="javadoc-to-mdoc">The lock associated with this condition is atomically
 released and the current thread becomes disabled for thread scheduling
 purposes and lies dormant until <i>one</i> of three things happens:
 <list type="bullet"><item><term>Some other thread invokes the <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.Signal" /></c> method for this
 <c>Condition</c> and the current thread happens to be chosen as the
 thread to be awakened; or
 </term></item><item><term>Some other thread invokes the <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.SignalAll" /></c> method for this
 <c>Condition</c>; or
 </term></item><item><term>A "<i>spurious wakeup</i>" occurs.
 </term></item></list></para><para tool="javadoc-to-mdoc">In all cases, before this method can return the current thread must
 re-acquire the lock associated with this condition. When the
 thread returns it is <i>guaranteed</i> to hold this lock.

 </para><para tool="javadoc-to-mdoc">If the current thread's interrupted status is set when it enters
 this method, or it is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>
 while waiting, it will continue to wait until signalled. When it finally
 returns from this method its interrupted status will still
 be set.

 </para><para tool="javadoc-to-mdoc"><format type="text/html"><b>Implementation Considerations</b></format></para><para tool="javadoc-to-mdoc">The current thread is assumed to hold the lock associated with this
 <c>Condition</c> when this method is called.
 It is up to the implementation to determine if this is
 the case and if not, how to respond. Typically, an exception will be
 thrown (such as <c><see cref="T:Java.Lang.IllegalMonitorStateException" /></c>) and the
 implementation must document that fact.
</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/Condition.html#awaitUninterruptibly()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="AwaitUntil">
      <MemberSignature Language="C#" Value="public bool AwaitUntil (Java.Util.Date deadline);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool AwaitUntil(class Java.Util.Date deadline) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("awaitUntil", "(Ljava/util/Date;)Z", "GetAwaitUntil_Ljava_util_Date_Handler:Java.Util.Concurrent.Locks.IConditionInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deadline" Type="Java.Util.Date" />
      </Parameters>
      <Docs>
        <param name="deadline">the absolute time to wait until</param>
        <summary>Causes the current thread to wait until it is signalled or interrupted,
 or the specified deadline elapses.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Causes the current thread to wait until it is signalled or interrupted,
 or the specified deadline elapses.

 </para><para tool="javadoc-to-mdoc">The lock associated with this condition is atomically
 released and the current thread becomes disabled for thread scheduling
 purposes and lies dormant until <i>one</i> of five things happens:
 <list type="bullet"><item><term>Some other thread invokes the <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.Signal" /></c> method for this
 <c>Condition</c> and the current thread happens to be chosen as the
 thread to be awakened; or
 </term></item><item><term>Some other thread invokes the <c><see cref="M:Java.Util.Concurrent.Locks.ICondition.SignalAll" /></c> method for this
 <c>Condition</c>; or
 </term></item><item><term>Some other thread <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> the
 current thread, and interruption of thread suspension is supported; or
 </term></item><item><term>The specified deadline elapses; or
 </term></item><item><term>A "<i>spurious wakeup</i>" occurs.
 </term></item></list></para><para tool="javadoc-to-mdoc">In all cases, before this method can return the current thread must
 re-acquire the lock associated with this condition. When the
 thread returns it is <i>guaranteed</i> to hold this lock.


 </para><para tool="javadoc-to-mdoc">If the current thread:
 <list type="bullet"><item><term>has its interrupted status set on entry to this method; or
 </term></item><item><term>is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> while waiting
 and interruption of thread suspension is supported,
 </term></item></list>
 then <c><see cref="T:Java.Lang.InterruptedException" /></c> is thrown and the current thread's
 interrupted status is cleared. It is not specified, in the first
 case, whether or not the test for interruption occurs before the lock
 is released.


 </para><para tool="javadoc-to-mdoc">The return value indicates whether the deadline has elapsed,
 which can be used as follows:
  <example><code lang="java">boolean aMethod(Date deadline) {
   boolean stillWaiting = true;
   lock.lock();
   try {
     while (!conditionBeingWaitedFor()) {
       if (!stillWaiting)
         return false;
       stillWaiting = theCondition.awaitUntil(deadline);
     
     // ...
   } finally {
     lock.unlock();
   }
 }}</code></example></para><para tool="javadoc-to-mdoc"><format type="text/html"><b>Implementation Considerations</b></format></para><para tool="javadoc-to-mdoc">The current thread is assumed to hold the lock associated with this
 <c>Condition</c> when this method is called.
 It is up to the implementation to determine if this is
 the case and if not, how to respond. Typically, an exception will be
 thrown (such as <c><see cref="T:Java.Lang.IllegalMonitorStateException" /></c>) and the
 implementation must document that fact.

 </para><para tool="javadoc-to-mdoc">An implementation can favor responding to an interrupt over normal
 method return in response to a signal, or over indicating the passing
 of the specified deadline. In either case the implementation
 must ensure that the signal is redirected to another waiting thread, if
 there is one.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/Condition.html#awaitUntil(java.util.Date)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.InterruptedException">if the current thread is interrupted
         (and interruption of thread suspension is supported)
</exception>
      </Docs>
    </Member>
    <Member MemberName="Signal">
      <MemberSignature Language="C#" Value="public void Signal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Signal() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("signal", "()V", "GetSignalHandler:Java.Util.Concurrent.Locks.IConditionInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wakes up one waiting thread.</summary>
        <remarks><para tool="javadoc-to-mdoc">Wakes up one waiting thread.

 </para><para tool="javadoc-to-mdoc">If any threads are waiting on this condition then one
 is selected for waking up. That thread must then re-acquire the
 lock before returning from <c>await</c>.

 </para><para tool="javadoc-to-mdoc"><format type="text/html"><b>Implementation Considerations</b></format></para><para tool="javadoc-to-mdoc">An implementation may (and typically does) require that the
 current thread hold the lock associated with this <c>Condition</c> when this method is called. Implementations must
 document this precondition and any actions taken if the lock is
 not held. Typically, an exception such as <c><see cref="T:Java.Lang.IllegalMonitorStateException" /></c> will be thrown.
</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/Condition.html#signal()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="SignalAll">
      <MemberSignature Language="C#" Value="public void SignalAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SignalAll() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("signalAll", "()V", "GetSignalAllHandler:Java.Util.Concurrent.Locks.IConditionInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wakes up all waiting threads.</summary>
        <remarks><para tool="javadoc-to-mdoc">Wakes up all waiting threads.

 </para><para tool="javadoc-to-mdoc">If any threads are waiting on this condition then they are
 all woken up. Each thread must re-acquire the lock before it can
 return from <c>await</c>.

 </para><para tool="javadoc-to-mdoc"><format type="text/html"><b>Implementation Considerations</b></format></para><para tool="javadoc-to-mdoc">An implementation may (and typically does) require that the
 current thread hold the lock associated with this <c>Condition</c> when this method is called. Implementations must
 document this precondition and any actions taken if the lock is
 not held. Typically, an exception such as <c><see cref="T:Java.Lang.IllegalMonitorStateException" /></c> will be thrown.
</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/Condition.html#signalAll()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
  </Members>
</Type>
