<Type Name="ReentrantReadWriteLock" FullName="Java.Util.Concurrent.Locks.ReentrantReadWriteLock">
  <TypeSignature Language="C#" Value="public class ReentrantReadWriteLock : Java.Lang.Object, IDisposable, Java.IO.ISerializable, Java.Util.Concurrent.Locks.IReadWriteLock" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ReentrantReadWriteLock extends Java.Lang.Object implements class Android.Runtime.IJavaObject, class Java.IO.ISerializable, class Java.Util.Concurrent.Locks.IReadWriteLock, class System.IDisposable" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>Java.IO.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>Java.Util.Concurrent.Locks.IReadWriteLock</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("java/util/concurrent/locks/ReentrantReadWriteLock", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>An implementation of <c><see cref="T:Java.Util.Concurrent.Locks.IReadWriteLock" /></c> supporting similar
 semantics to <c><see cref="T:Java.Util.Concurrent.Locks.ReentrantLock" /></c>.</summary>
    <remarks><para tool="javadoc-to-mdoc">An implementation of <c><see cref="T:Java.Util.Concurrent.Locks.IReadWriteLock" /></c> supporting similar
 semantics to <c><see cref="T:Java.Util.Concurrent.Locks.ReentrantLock" /></c>.
 </para><para tool="javadoc-to-mdoc">This class has the following properties:

 <list type="bullet"><item><term><format type="text/html"><b>Acquisition order</b></format>This class does not impose a reader or writer preference
 ordering for lock access.  However, it does support an optional
 <i>fairness</i> policy.

 <format type="text/html"><dl><dt><b><i>Non-fair mode (default)</i></b><dd>When constructed as non-fair (the default), the order of entry
 to the read and write lock is unspecified, subject to reentrancy
 constraints.  A nonfair lock that is continuously contended may
 indefinitely postpone one or more reader or writer threads, but
 will normally have higher throughput than a fair lock.
 <dt><b><i>Fair mode</i></b><dd>When constructed as fair, threads contend for entry using an
 approximately arrival-order policy. When the currently held lock
 is released, either the longest-waiting single writer thread will
 be assigned the write lock, or if there is a group of reader threads
 waiting longer than all waiting writer threads, that group will be
 assigned the read lock.

 A thread that tries to acquire a fair read lock (non-reentrantly)
 will block if either the write lock is held, or there is a waiting
 writer thread. The thread will not acquire the read lock until
 after the oldest currently waiting writer thread has acquired and
 released the write lock. Of course, if a waiting writer abandons
 its wait, leaving one or more reader threads as the longest waiters
 in the queue with the write lock free, then those readers will be
 assigned the read lock.

 A thread that tries to acquire a fair write lock (non-reentrantly)
 will block unless both the read lock and write lock are free (which
 implies there are no waiting threads).  (Note that the non-blocking
 <c><see cref="!:NoType:java/util/concurrent/locks/ReentrantReadWriteLock$ReadLock;Href=../../../../../reference/java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html#tryLock()" /></c> and <c><see cref="!:NoType:java/util/concurrent/locks/ReentrantReadWriteLock$WriteLock;Href=../../../../../reference/java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#tryLock()" /></c> methods
 do not honor this fair setting and will immediately acquire the lock
 if it is possible, regardless of waiting threads.)
 </dd></dt></dd></dt></dl></format></term></item><item><term><format type="text/html"><b>Reentrancy</b></format>This lock allows both readers and writers to reacquire read or
 write locks in the style of a <c><see cref="T:Java.Util.Concurrent.Locks.ReentrantLock" /></c>. Non-reentrant
 readers are not allowed until all write locks held by the writing
 thread have been released.

 Additionally, a writer can acquire the read lock, but not
 vice-versa.  Among other applications, reentrancy can be useful
 when write locks are held during calls or callbacks to methods that
 perform reads under read locks.  If a reader tries to acquire the
 write lock it will never succeed.

 </term></item><item><term><format type="text/html"><b>Lock downgrading</b></format>Reentrancy also allows downgrading from the write lock to a read lock,
 by acquiring the write lock, then the read lock and then releasing the
 write lock. However, upgrading from a read lock to the write lock is
 <format type="text/html"><b>not</b></format> possible.

 </term></item><item><term><format type="text/html"><b>Interruption of lock acquisition</b></format>The read lock and write lock both support interruption during lock
 acquisition.

 </term></item><item><term><format type="text/html"><b><c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c> support</b></format>The write lock provides a <c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c> implementation that
 behaves in the same way, with respect to the write lock, as the
 <c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c> implementation provided by
 <c><see cref="M:Java.Util.Concurrent.Locks.ReentrantLock.NewCondition" /></c> does for <c><see cref="T:Java.Util.Concurrent.Locks.ReentrantLock" /></c>.
 This <c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c> can, of course, only be used with the write lock.

 The read lock does not support a <c><see cref="T:Java.Util.Concurrent.Locks.ICondition" /></c> and
 <c>readLock().newCondition()</c> throws
 <c>UnsupportedOperationException</c>.

 </term></item><item><term><format type="text/html"><b>Instrumentation</b></format>This class supports methods to determine whether locks
 are held or contended. These methods are designed for monitoring
 system state, not for synchronization control.
 </term></item></list></para><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc" /><para tool="javadoc-to-mdoc">Serialization of this class behaves in the same way as built-in
 locks: a deserialized lock is in the unlocked state, regardless of
 its state when serialized.

 </para><para tool="javadoc-to-mdoc"><format type="text/html"><b>Sample usages</b></format>. Here is a code sketch showing how to perform
 lock downgrading after updating a cache (exception handling is
 particularly tricky when handling multiple locks in a non-nested
 fashion):

 <example><code lang="java">class CachedData {
   Object data;
   volatile boolean cacheValid;
   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock().lock();
     if (!cacheValid) {
       // Must release read lock before acquiring write lock
       rwl.readLock().unlock();
       rwl.writeLock().lock();
       try {
         // Recheck state because another thread might have
         // acquired write lock and changed state before we did.
         if (!cacheValid) {
           data = ...
           cacheValid = true;
         
         // Downgrade by acquiring read lock before releasing write lock
         rwl.readLock().lock();
       } finally {
         rwl.writeLock().unlock(); // Unlock write, still hold read
       }
     }

     try {
       use(data);
     } finally {
       rwl.readLock().unlock();
     }
   }
 }}</code></example>

 ReentrantReadWriteLocks can be used to improve concurrency in some
 uses of some kinds of Collections. This is typically worthwhile
 only when the collections are expected to be large, accessed by
 more reader threads than writer threads, and entail operations with
 overhead that outweighs synchronization overhead. For example, here
 is a class using a TreeMap that is expected to be large and
 concurrently accessed.

  <example><code lang="java">class RWDictionary {
   private final Map m = new TreeMap();
   private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
   private final Lock r = rwl.readLock();
   private final Lock w = rwl.writeLock();

   public Data get(String key) {
     r.lock();
     try { return m.get(key); 
     finally { r.unlock(); }
   }
   public String[] allKeys() {
     r.lock();
     try { return m.keySet().toArray(); }
     finally { r.unlock(); }
   }
   public Data put(String key, Data value) {
     w.lock();
     try { return m.put(key, value); }
     finally { w.unlock(); }
   }
   public void clear() {
     w.lock();
     try { m.clear(); }
     finally { w.unlock(); }
   }
 }}</code></example><format type="text/html"><h3>Implementation Notes</h3></format></para><para tool="javadoc-to-mdoc">This lock supports a maximum of 65535 recursive write locks
 and 65535 read locks. Attempts to exceed these limits result in
 <c><see cref="T:Java.Lang.Error" /></c> throws from locking methods.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_blank">[Android Documentation]</a></format></para></remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReentrantReadWriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "()V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Creates a new <c>ReentrantReadWriteLock</c> with
 default (nonfair) ordering properties.</summary>
        <remarks><para tool="javadoc-to-mdoc">Creates a new <c>ReentrantReadWriteLock</c> with
 default (nonfair) ordering properties.
</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#ReentrantReadWriteLock()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReentrantReadWriteLock (bool fair);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool fair) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(Z)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fair" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fair">To be added.</param>
        <summary>Creates a new <c>ReentrantReadWriteLock</c> with
 the given fairness policy.</summary>
        <remarks><para tool="javadoc-to-mdoc">Creates a new <c>ReentrantReadWriteLock</c> with
 the given fairness policy.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#ReentrantReadWriteLock(boolean)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ReentrantReadWriteLock (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This constructor is invoked by the runtime infrastructure (<see cref="M:Java.Lang.Object.GetObject``1(System.IntPtr,Android.Runtime.JniHandleOwnership)" />) to create a new managed representation for a Java Native Interface object.</para>
          <para tool="javadoc-to-mdoc">The constructor will initializes the <see cref="P:Android.Runtime.IJavaObject.Handle" /> property of the new instance using <paramref name="javaReference" /> and <paramref name="transfer" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWaitingThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt; GetWaitingThreads (Java.Util.Concurrent.Locks.ICondition condition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; GetWaitingThreads(class Java.Util.Concurrent.Locks.ICondition condition) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("getWaitingThreads", "(Ljava/util/concurrent/locks/Condition;)Ljava/util/Collection;", "GetGetWaitingThreads_Ljava_util_concurrent_locks_Condition_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="Java.Util.Concurrent.Locks.ICondition" />
      </Parameters>
      <Docs>
        <param name="condition">the condition</param>
        <summary>Returns a collection containing those threads that may be
 waiting on the given condition associated with the write lock.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Returns a collection containing those threads that may be
 waiting on the given condition associated with the write lock.
 Because the actual set of threads may change dynamically while
 constructing this result, the returned collection is only a
 best-effort estimate. The elements of the returned collection
 are in no particular order.  This method is designed to
 facilitate construction of subclasses that provide more
 extensive condition monitoring facilities.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getWaitingThreads(java.util.concurrent.locks.Condition)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if this lock is not held</exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the given condition is
         not associated with this lock</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the condition is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="GetWaitQueueLength">
      <MemberSignature Language="C#" Value="public virtual int GetWaitQueueLength (Java.Util.Concurrent.Locks.ICondition condition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetWaitQueueLength(class Java.Util.Concurrent.Locks.ICondition condition) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("getWaitQueueLength", "(Ljava/util/concurrent/locks/Condition;)I", "GetGetWaitQueueLength_Ljava_util_concurrent_locks_Condition_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="Java.Util.Concurrent.Locks.ICondition" />
      </Parameters>
      <Docs>
        <param name="condition">the condition</param>
        <summary>Returns an estimate of the number of threads waiting on the
 given condition associated with the write lock.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Returns an estimate of the number of threads waiting on the
 given condition associated with the write lock. Note that because
 timeouts and interrupts may occur at any time, the estimate
 serves only as an upper bound on the actual number of waiters.
 This method is designed for use in monitoring of the system
 state, not for synchronization control.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getWaitQueueLength(java.util.concurrent.locks.Condition)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if this lock is not held</exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the given condition is
         not associated with this lock</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the condition is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="HasQueuedThread">
      <MemberSignature Language="C#" Value="public bool HasQueuedThread (Java.Lang.Thread thread);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasQueuedThread(class Java.Lang.Thread thread) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("hasQueuedThread", "(Ljava/lang/Thread;)Z", "")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="thread" Type="Java.Lang.Thread" />
      </Parameters>
      <Docs>
        <param name="thread">the thread</param>
        <summary>Queries whether the given thread is waiting to acquire either
 the read or write lock.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Queries whether the given thread is waiting to acquire either
 the read or write lock. Note that because cancellations may
 occur at any time, a <c>true</c> return does not guarantee
 that this thread will ever acquire a lock.  This method is
 designed primarily for use in monitoring of the system state.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#hasQueuedThread(java.lang.Thread)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.NullPointerException">if the thread is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="HasQueuedThreads">
      <MemberSignature Language="C#" Value="public bool HasQueuedThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasQueuedThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("hasQueuedThreads", "()Z", "GetHasQueuedThreadsHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries whether any threads are waiting to acquire the read or
 write lock.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries whether any threads are waiting to acquire the read or
 write lock. Note that because cancellations may occur at any
 time, a <c>true</c> return does not guarantee that any other
 thread will ever acquire a lock.  This method is designed
 primarily for use in monitoring of the system state.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#hasQueuedThreads()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="HasWaiters">
      <MemberSignature Language="C#" Value="public virtual bool HasWaiters (Java.Util.Concurrent.Locks.ICondition condition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasWaiters(class Java.Util.Concurrent.Locks.ICondition condition) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("hasWaiters", "(Ljava/util/concurrent/locks/Condition;)Z", "GetHasWaiters_Ljava_util_concurrent_locks_Condition_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="condition" Type="Java.Util.Concurrent.Locks.ICondition" />
      </Parameters>
      <Docs>
        <param name="condition">the condition</param>
        <summary>Queries whether any threads are waiting on the given condition
 associated with the write lock.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Queries whether any threads are waiting on the given condition
 associated with the write lock. Note that because timeouts and
 interrupts may occur at any time, a <c>true</c> return does
 not guarantee that a future <c>signal</c> will awaken any
 threads.  This method is designed primarily for use in
 monitoring of the system state.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#hasWaiters(java.util.concurrent.locks.Condition)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalMonitorStateException">if this lock is not held</exception>
        <exception cref="T:Java.Lang.IllegalArgumentException">if the given condition is
         not associated with this lock</exception>
        <exception cref="T:Java.Lang.NullPointerException">if the condition is null
</exception>
      </Docs>
    </Member>
    <Member MemberName="IsFair">
      <MemberSignature Language="C#" Value="public bool IsFair { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFair" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isFair", "()Z", "GetIsFairHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns <c>true</c> if this lock has fairness set true.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns <c>true</c> if this lock has fairness set true.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#isFair()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsWriteLocked">
      <MemberSignature Language="C#" Value="public virtual bool IsWriteLocked { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLocked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isWriteLocked", "()Z", "GetIsWriteLockedHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries if the write lock is held by any thread.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries if the write lock is held by any thread. This method is
 designed for use in monitoring system state, not for
 synchronization control.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#isWriteLocked()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="IsWriteLockedByCurrentThread">
      <MemberSignature Language="C#" Value="public virtual bool IsWriteLockedByCurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriteLockedByCurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("isWriteLockedByCurrentThread", "()Z", "GetIsWriteLockedByCurrentThreadHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries if the write lock is held by the current thread.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries if the write lock is held by the current thread.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#isWriteLockedByCurrentThread()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="protected virtual Java.Lang.Thread Owner { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Java.Lang.Thread Owner" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getOwner", "()Ljava/lang/Thread;", "GetGetOwnerHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Lang.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the thread that currently owns the write lock, or
 <c>null</c> if not owned.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns the thread that currently owns the write lock, or
 <c>null</c> if not owned. When this method is called by a
 thread that is not the owner, the return value reflects a
 best-effort approximation of current lock status. For example,
 the owner may be momentarily <c>null</c> even if there are
 threads trying to acquire the lock but have not yet done so.
 This method is designed to facilitate construction of
 subclasses that provide more extensive lock monitoring
 facilities.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getOwner()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueuedReaderThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt; QueuedReaderThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; QueuedReaderThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getQueuedReaderThreads", "()Ljava/util/Collection;", "GetGetQueuedReaderThreadsHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection containing threads that may be waiting to
 acquire the read lock.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns a collection containing threads that may be waiting to
 acquire the read lock.  Because the actual set of threads may
 change dynamically while constructing this result, the returned
 collection is only a best-effort estimate.  The elements of the
 returned collection are in no particular order.  This method is
 designed to facilitate construction of subclasses that provide
 more extensive lock monitoring facilities.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedReaderThreads()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueuedThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt; QueuedThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; QueuedThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getQueuedThreads", "()Ljava/util/Collection;", "GetGetQueuedThreadsHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection containing threads that may be waiting to
 acquire either the read or write lock.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns a collection containing threads that may be waiting to
 acquire either the read or write lock.  Because the actual set
 of threads may change dynamically while constructing this
 result, the returned collection is only a best-effort estimate.
 The elements of the returned collection are in no particular
 order.  This method is designed to facilitate construction of
 subclasses that provide more extensive monitoring facilities.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedThreads()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueuedWriterThreads">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt; QueuedWriterThreads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Java.Lang.Thread&gt; QueuedWriterThreads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getQueuedWriterThreads", "()Ljava/util/Collection;", "GetGetQueuedWriterThreadsHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Java.Lang.Thread&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a collection containing threads that may be waiting to
 acquire the write lock.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns a collection containing threads that may be waiting to
 acquire the write lock.  Because the actual set of threads may
 change dynamically while constructing this result, the returned
 collection is only a best-effort estimate.  The elements of the
 returned collection are in no particular order.  This method is
 designed to facilitate construction of subclasses that provide
 more extensive lock monitoring facilities.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedWriterThreads()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="QueueLength">
      <MemberSignature Language="C#" Value="public int QueueLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 QueueLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getQueueLength", "()I", "GetGetQueueLengthHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns an estimate of the number of threads waiting to acquire
 either the read or write lock.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns an estimate of the number of threads waiting to acquire
 either the read or write lock.  The value is only an estimate
 because the number of threads may change dynamically while this
 method traverses internal data structures.  This method is
 designed for use in monitoring of the system state, not for
 synchronization control.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueueLength()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ReadHoldCount">
      <MemberSignature Language="C#" Value="public virtual int ReadHoldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadHoldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getReadHoldCount", "()I", "GetGetReadHoldCountHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries the number of reentrant read holds on this lock by the
 current thread.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries the number of reentrant read holds on this lock by the
 current thread.  A reader thread has a hold on a lock for
 each lock action that is not matched by an unlock action.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getReadHoldCount()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 9" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="public virtual Java.Util.Concurrent.Locks.ILock ReadLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Java.Util.Concurrent.Locks.ILock ReadLock() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("readLock", "()Ljava/util/concurrent/locks/Lock;", "GetReadLockHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.Concurrent.Locks.ILock</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the lock used for reading.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Returns the lock used for reading.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#readLock()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ReadLockCount">
      <MemberSignature Language="C#" Value="public virtual int ReadLockCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadLockCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getReadLockCount", "()I", "GetGetReadLockCountHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries the number of read locks held for this lock.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries the number of read locks held for this lock. This
 method is designed for use in monitoring system state, not for
 synchronization control.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getReadLockCount()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonVirtualVoidMethod" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteHoldCount">
      <MemberSignature Language="C#" Value="public virtual int WriteHoldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteHoldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getWriteHoldCount", "()I", "GetGetWriteHoldCountHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Queries the number of reentrant write holds on this lock by the
 current thread.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Queries the number of reentrant write holds on this lock by the
 current thread.  A writer thread has a hold on a lock for
 each lock action that is not matched by an unlock action.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#getWriteHoldCount()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="public virtual Java.Util.Concurrent.Locks.ILock WriteLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Java.Util.Concurrent.Locks.ILock WriteLock() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("writeLock", "()Ljava/util/concurrent/locks/Lock;", "GetWriteLockHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Java.Util.Concurrent.Locks.ILock</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the lock used for writing.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Returns the lock used for writing.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/locks/ReentrantReadWriteLock.html#writeLock()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
  </Members>
</Type>
