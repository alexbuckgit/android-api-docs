<Namespace Name="Java.Util.Concurrent.Atomic">
  <Docs>
    <summary>This method (which varies in argument types across different
 classes) atomically sets a variable to the <c>updateValue</c> if it
 currently holds the <c>expectedValue</c>, reporting <c>true</c> on
 success.</summary>
    <remarks>
    A small toolkit of classes that support lock-free thread-safe
 programming on single variables.  In essence, the classes in this
 package extend the notion of <c>volatile</c> values, fields, and
 array elements to those that also provide an atomic conditional update
 operation of the form:

  <example><code lang="java">boolean compareAndSet(expectedValue, updateValue);</code></example><para tool="javadoc-to-mdoc">This method (which varies in argument types across different
 classes) atomically sets a variable to the <c>updateValue</c> if it
 currently holds the <c>expectedValue</c>, reporting <c>true</c> on
 success.  The classes in this package also contain methods to get and
 unconditionally set values, as well as a weaker conditional atomic
 update operation <c>weakCompareAndSet</c> described below.

 </para><para tool="javadoc-to-mdoc">The specifications of these methods enable implementations to
 employ efficient machine-level atomic instructions that are available
 on contemporary processors.  However on some platforms, support may
 entail some form of internal locking.  Thus the methods are not
 strictly guaranteed to be non-blocking --
 a thread may block transiently before performing the operation.

 </para><para tool="javadoc-to-mdoc">Instances of classes
 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicBoolean" /></c>,
 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicInteger" /></c>,
 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicLong" /></c>, and
 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicReference" /></c>
 each provide access and updates to a single variable of the
 corresponding type.  Each class also provides appropriate utility
 methods for that type.  For example, classes <c>AtomicLong</c> and
 <c>AtomicInteger</c> provide atomic increment methods.  One
 application is to generate sequence numbers, as in:

  <example><code lang="java">class Sequencer {
   private final AtomicLong sequenceNumber
     = new AtomicLong(0);
   public long next() {
     return sequenceNumber.getAndIncrement();
   
 }}</code></example></para><para tool="javadoc-to-mdoc">It is straightforward to define new utility functions that, like
 <c>getAndIncrement</c>, apply a function to a value atomically.
 For example, given some transformation
 <example><code lang="java">long transform(long input)</code></example>

 write your utility method as follows:
  <example><code lang="java">long getAndTransform(AtomicLong var) {
   while (true) {
     long current = var.get();
     long next = transform(current);
     if (var.compareAndSet(current, next))
         return current;
         // return next; for transformAndGet
   
 }}</code></example></para><para tool="javadoc-to-mdoc">The memory effects for accesses and updates of atomics generally
 follow the rules for volatiles, as stated in
 :

 <list type="bullet"><item><term><c>get</c> has the memory effects of reading a
 <c>volatile</c> variable.

   </term></item><item><term><c>set</c> has the memory effects of writing (assigning) a
 <c>volatile</c> variable.

   </term></item><item><term><c>lazySet</c> has the memory effects of writing (assigning)
   a <c>volatile</c> variable except that it permits reorderings with
   subsequent (but not previous) memory actions that do not themselves
   impose reordering constraints with ordinary non-<c>volatile</c>
   writes.  Among other usage contexts, <c>lazySet</c> may apply when
   nulling out, for the sake of garbage collection, a reference that is
   never accessed again.

   </term></item><item><term><c>weakCompareAndSet</c> atomically reads and conditionally
   writes a variable but does <i>not</i>
   create any happens-before orderings, so provides no guarantees
   with respect to previous or subsequent reads and writes of any
   variables other than the target of the <c>weakCompareAndSet</c>.

   </term></item><item><term><c>compareAndSet</c>
   and all other read-and-update operations such as <c>getAndIncrement</c>
   have the memory effects of both reading and
   writing <c>volatile</c> variables.
 </term></item></list></para><para tool="javadoc-to-mdoc">In addition to classes representing single values, this package
 contains <i>Updater</i> classes that can be used to obtain
 <c>compareAndSet</c> operations on any selected <c>volatile</c>
 field of any selected class.

 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicReferenceFieldUpdater" /></c>,
 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicIntegerFieldUpdater" /></c>, and
 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicLongFieldUpdater" /></c> are
 reflection-based utilities that provide access to the associated
 field types.  These are mainly of use in atomic data structures in
 which several <c>volatile</c> fields of the same node (for
 example, the links of a tree node) are independently subject to
 atomic updates.  These classes enable greater flexibility in how
 and when to use atomic updates, at the expense of more awkward
 reflection-based setup, less convenient usage, and weaker
 guarantees.

 </para><para tool="javadoc-to-mdoc">The
 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicIntegerArray" /></c>,
 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicLongArray" /></c>, and
 <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicReferenceArray" /></c> classes
 further extend atomic operation support to arrays of these types.
 These classes are also notable in providing <c>volatile</c> access
 semantics for their array elements, which is not supported for
 ordinary arrays.

 </para><para tool="javadoc-to-mdoc">The atomic classes also support method
 <c>weakCompareAndSet</c>, which has limited applicability.  On some
 platforms, the weak version may be more efficient than <c>compareAndSet</c> in the normal case, but differs in that any given
 invocation of the <c>weakCompareAndSet</c> method may return <c>false</c><i>spuriously</i> (that is, for no apparent reason).  A
 <c>false</c> return means only that the operation may be retried if
 desired, relying on the guarantee that repeated invocation when the
 variable holds <c>expectedValue</c> and no other thread is also
 attempting to set the variable will eventually succeed.  (Such
 spurious failures may for example be due to memory contention effects
 that are unrelated to whether the expected and current values are
 equal.)  Additionally <c>weakCompareAndSet</c> does not provide
 ordering guarantees that are usually needed for synchronization
 control.  However, the method may be useful for updating counters and
 statistics when such updates are unrelated to the other
 happens-before orderings of a program.  When a thread sees an update
 to an atomic variable caused by a <c>weakCompareAndSet</c>, it does
 not necessarily see updates to any <i>other</i> variables that
 occurred before the <c>weakCompareAndSet</c>.  This may be
 acceptable when, for example, updating performance statistics, but
 rarely otherwise.

 </para><para tool="javadoc-to-mdoc">The <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicMarkableReference" /></c>
 class associates a single boolean with a reference.  For example, this
 bit might be used inside a data structure to mean that the object
 being referenced has logically been deleted.

 The <c><see cref="T:Java.Util.Concurrent.Atomic.AtomicStampedReference" /></c>
 class associates an integer value with a reference.  This may be
 used for example, to represent version numbers corresponding to
 series of updates.

 </para><para tool="javadoc-to-mdoc">Atomic classes are designed primarily as building blocks for
 implementing non-blocking data structures and related infrastructure
 classes.  The <c>compareAndSet</c> method is not a general
 replacement for locking.  It applies only when critical updates for an
 object are confined to a <i>single</i> variable.

 </para><para tool="javadoc-to-mdoc">Atomic classes are not general purpose replacements for
 <c>java.lang.Integer</c> and related classes.  They do <i>not</i>
 define methods such as <c>equals</c>, <c>hashCode</c> and
 <c>compareTo</c>.  (Because atomic variables are expected to be
 mutated, they are poor choices for hash table keys.)  Additionally,
 classes are provided only for those types that are commonly useful in
 intended applications.  For example, there is no atomic class for
 representing <c>byte</c>.  In those infrequent cases where you would
 like to do so, you can use an <c>AtomicInteger</c> to hold
 <c>byte</c> values, and cast appropriately.

 You can also hold floats using
 <c><see cref="M:Java.Lang.Float.FloatToRawIntBits(System.Single)" /></c> and
 <c><see cref="M:Java.Lang.Float.IntBitsToFloat(System.Int32)" /></c> conversions, and doubles using
 <c><see cref="M:Java.Lang.Double.DoubleToRawLongBits(System.Double)" /></c> and
 <c><see cref="M:Java.Lang.Double.LongBitsToDouble(System.Int64)" /></c> conversions.
  </para></remarks>
  </Docs>
</Namespace>
