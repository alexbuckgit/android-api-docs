<Type Name="Presentation" FullName="Android.App.Presentation">
  <TypeSignature Language="C#" Value="public class Presentation : Android.App.Dialog" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Presentation extends Android.App.Dialog" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Android.App.Dialog</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("android/app/Presentation", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs since="17">
    <summary>Base class for presentations.</summary>
    <remarks>
      <para tool="javadoc-to-mdoc">Base class for presentations.
 <format type="text/html"><h3>Choosing a presentation display</h3></format><format type="text/html"><h4>Using the media router to choose a presentation display</h4></format><example><code lang="java">
 MediaRouter mediaRouter = (MediaRouter) context.getSystemService(Context.MEDIA_ROUTER_SERVICE);
 MediaRouter.RouteInfo route = mediaRouter.getSelectedRoute();
 if (route != null) {
     Display presentationDisplay = route.getPresentationDisplay();
     if (presentationDisplay != null) {
         Presentation presentation = new MyPresentation(context, presentationDisplay);
         presentation.show();
     }
 }</code></example><example><code lang="java">/**
 * &lt;h3&gt;Presentation Activity&lt;/h3&gt;
 *
 * &lt;p&gt;
 * This demonstrates how to create an activity that shows some content
 * on a secondary display using a {@link Presentation}.
 * &lt;/p&gt;&lt;p&gt;
 * The activity uses the {@link MediaRouter} API to automatically detect when
 * a presentation display is available and to allow the user to control the
 * media routes using a menu item.  When a presentation display is available,
 * we stop showing content in the main activity and instead open up a
 * {@link Presentation} on the preferred presentation display.  When a presentation
 * display is removed, we revert to showing content in the main activity.
 * We also write information about displays and display-related events to
 * the Android log which you can read using &lt;code&gt;adb logcat&lt;/code&gt;.
 * &lt;/p&gt;&lt;p&gt;
 * You can try this out using an HDMI or Wifi display or by using the
 * "Simulate secondary displays" feature in Development Settings to create a few
 * simulated secondary displays.  Each display will appear in the list along with a
 * checkbox to show a presentation on that display.
 * &lt;/p&gt;&lt;p&gt;
 * See also the {@link PresentationActivity} sample which
 * uses the low-level display manager to enumerate displays and to show multiple
 * simultaneous presentations on different displays.
 * &lt;/p&gt;
 */
public class PresentationWithMediaRouterActivity extends Activity {
    private final String TAG = "PresentationWithMediaRouterActivity";

    private MediaRouter mMediaRouter;
    private DemoPresentation mPresentation;
    private GLSurfaceView mSurfaceView;
    private TextView mInfoTextView;
    private boolean mPaused;

    /**
     * Initialization of the Activity after it is first created.  Must at least
     * call {@link android.app.Activity#setContentView setContentView()} to
     * describe what is to be displayed in the screen.
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // Be sure to call the super class.
        super.onCreate(savedInstanceState);

        // Get the media router service.
        mMediaRouter = (MediaRouter)getSystemService(Context.MEDIA_ROUTER_SERVICE);

        // See assets/res/any/layout/presentation_with_media_router_activity.xml for this
        // view layout definition, which is being set here as
        // the content of our screen.
        setContentView(R.layout.presentation_with_media_router_activity);

        // Set up the surface view for visual interest.
        mSurfaceView = (GLSurfaceView)findViewById(R.id.surface_view);
        mSurfaceView.setRenderer(new CubeRenderer(false));

        // Get a text view where we will show information about what's happening.
        mInfoTextView = (TextView)findViewById(R.id.info);
    }

    @Override
    protected void onResume() {
        // Be sure to call the super class.
        super.onResume();

        // Listen for changes to media routes.
        mMediaRouter.addCallback(MediaRouter.ROUTE_TYPE_LIVE_VIDEO, mMediaRouterCallback);

        // Update the presentation based on the currently selected route.
        mPaused = false;
        updatePresentation();
    }

    @Override
    protected void onPause() {
        // Be sure to call the super class.
        super.onPause();

        // Stop listening for changes to media routes.
        mMediaRouter.removeCallback(mMediaRouterCallback);

        // Pause rendering.
        mPaused = true;
        updateContents();
    }

    @Override
    protected void onStop() {
        // Be sure to call the super class.
        super.onStop();

        // Dismiss the presentation when the activity is not visible.
        if (mPresentation != null) {
            Log.i(TAG, "Dismissing presentation because the activity is no longer visible.");
            mPresentation.dismiss();
            mPresentation = null;
        }
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Be sure to call the super class.
        super.onCreateOptionsMenu(menu);

        // Inflate the menu and configure the media router action provider.
        getMenuInflater().inflate(R.menu.presentation_with_media_router_menu, menu);

        MenuItem mediaRouteMenuItem = menu.findItem(R.id.menu_media_route);
        MediaRouteActionProvider mediaRouteActionProvider =
                (MediaRouteActionProvider)mediaRouteMenuItem.getActionProvider();
        mediaRouteActionProvider.setRouteTypes(MediaRouter.ROUTE_TYPE_LIVE_VIDEO);

        // Return true to show the menu.
        return true;
    }

    private void updatePresentation() {
        // Get the current route and its presentation display.
        MediaRouter.RouteInfo route = mMediaRouter.getSelectedRoute(
                MediaRouter.ROUTE_TYPE_LIVE_VIDEO);
        Display presentationDisplay = route != null ? route.getPresentationDisplay() : null;

        // Dismiss the current presentation if the display has changed.
        if (mPresentation != null &amp;&amp; mPresentation.getDisplay() != presentationDisplay) {
            Log.i(TAG, "Dismissing presentation because the current route no longer "
                    + "has a presentation display.");
            mPresentation.dismiss();
            mPresentation = null;
        }

        // Show a new presentation if needed.
        if (mPresentation == null &amp;&amp; presentationDisplay != null) {
            Log.i(TAG, "Showing presentation on display: " + presentationDisplay);
            mPresentation = new DemoPresentation(this, presentationDisplay);
            mPresentation.setOnDismissListener(mOnDismissListener);
            try {
                mPresentation.show();
            } catch (WindowManager.InvalidDisplayException ex) {
                Log.w(TAG, "Couldn't show presentation!  Display was removed in "
                        + "the meantime.", ex);
                mPresentation = null;
            }
        }

        // Update the contents playing in this activity.
        updateContents();
    }

    private void updateContents() {
        // Show either the content in the main activity or the content in the presentation
        // along with some descriptive text about what is happening.
        if (mPresentation != null) {
            mInfoTextView.setText(getResources().getString(
                    R.string.presentation_with_media_router_now_playing_remotely,
                    mPresentation.getDisplay().getName()));
            mSurfaceView.setVisibility(View.INVISIBLE);
            mSurfaceView.onPause();
            if (mPaused) {
                mPresentation.getSurfaceView().onPause();
            } else {
                mPresentation.getSurfaceView().onResume();
            }
        } else {
            mInfoTextView.setText(getResources().getString(
                    R.string.presentation_with_media_router_now_playing_locally,
                    getWindowManager().getDefaultDisplay().getName()));
            mSurfaceView.setVisibility(View.VISIBLE);
            if (mPaused) {
                mSurfaceView.onPause();
            } else {
                mSurfaceView.onResume();
            }
        }
    }

    private final MediaRouter.SimpleCallback mMediaRouterCallback =
            new MediaRouter.SimpleCallback() {
        @Override
        public void onRouteSelected(MediaRouter router, int type, RouteInfo info) {
            Log.d(TAG, "onRouteSelected: type=" + type + ", info=" + info);
            updatePresentation();
        }

        @Override
        public void onRouteUnselected(MediaRouter router, int type, RouteInfo info) {
            Log.d(TAG, "onRouteUnselected: type=" + type + ", info=" + info);
            updatePresentation();
        }

        @Override
        public void onRoutePresentationDisplayChanged(MediaRouter router, RouteInfo info) {
            Log.d(TAG, "onRoutePresentationDisplayChanged: info=" + info);
            updatePresentation();
        }
    };

    /**
     * Listens for when presentations are dismissed.
     */
    private final DialogInterface.OnDismissListener mOnDismissListener =
            new DialogInterface.OnDismissListener() {
        @Override
        public void onDismiss(DialogInterface dialog) {
            if (dialog == mPresentation) {
                Log.i(TAG, "Presentation was dismissed.");
                mPresentation = null;
                updateContents();
            }
        }
    };

    /**
     * The presentation to show on the secondary display.
     * &lt;p&gt;
     * Note that this display may have different metrics from the display on which
     * the main activity is showing so we must be careful to use the presentation's
     * own {@link Context} whenever we load resources.
     * &lt;/p&gt;
     */
    private final static class DemoPresentation extends Presentation {
        private GLSurfaceView mSurfaceView;

        public DemoPresentation(Context context, Display display) {
            super(context, display);
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            // Be sure to call the super class.
            super.onCreate(savedInstanceState);

            // Get the resources for the context of the presentation.
            // Notice that we are getting the resources from the context of the presentation.
            Resources r = getContext().getResources();

            // Inflate the layout.
            setContentView(R.layout.presentation_with_media_router_content);

            // Set up the surface view for visual interest.
            mSurfaceView = (GLSurfaceView)findViewById(R.id.surface_view);
            mSurfaceView.setRenderer(new CubeRenderer(false));
        }

        public GLSurfaceView getSurfaceView() {
            return mSurfaceView;
        }
    }
}</code></example><format type="text/html"><h4>Using the display manager to choose a presentation display</h4></format><example><code lang="java">
 DisplayManager displayManager = (DisplayManager) context.getSystemService(Context.DISPLAY_SERVICE);
 Display[] presentationDisplays = displayManager.getDisplays(DisplayManager.DISPLAY_CATEGORY_PRESENTATION);
 if (presentationDisplays.length &gt; 0) {
     // If there is more than one suitable presentation display, then we could consider
     // giving the user a choice.  For this example, we simply choose the first display
     // which is the one the system recommends as the preferred presentation display.
     Display display = presentationDisplays[0];
     Presentation presentation = new MyPresentation(context, presentationDisplay);
     presentation.show();
 }</code></example><example><code lang="java">/**
 * &lt;h3&gt;Presentation Activity&lt;/h3&gt;
 *
 * &lt;p&gt;
 * This demonstrates how to create an activity that shows some content
 * on a secondary display using a {@link Presentation}.
 * &lt;/p&gt;&lt;p&gt;
 * The activity uses the {@link DisplayManager} API to enumerate displays.
 * When the user selects a display, the activity opens a {@link Presentation}
 * on that display.  We show a different photograph in each presentation
 * on a unique background along with a label describing the display.
 * We also write information about displays and display-related events to
 * the Android log which you can read using &lt;code&gt;adb logcat&lt;/code&gt;.
 * &lt;/p&gt;&lt;p&gt;
 * You can try this out using an HDMI or Wifi display or by using the
 * "Simulate secondary displays" feature in Development Settings to create a few
 * simulated secondary displays.  Each display will appear in the list along with a
 * checkbox to show a presentation on that display.
 * &lt;/p&gt;&lt;p&gt;
 * See also the {@link PresentationWithMediaRouterActivity} sample which
 * uses the media router to automatically select a secondary display
 * on which to show content based on the currently selected route.
 * &lt;/p&gt;
 */
public class PresentationActivity extends Activity
        implements OnCheckedChangeListener, OnClickListener {
    private final String TAG = "PresentationActivity";

    // Key for storing saved instance state.
    private static final String PRESENTATION_KEY = "presentation";

    // The content that we want to show on the presentation.
    private static final int[] PHOTOS = new int[] {
        R.drawable.frantic,
        R.drawable.photo1, R.drawable.photo2, R.drawable.photo3,
        R.drawable.photo4, R.drawable.photo5, R.drawable.photo6,
        R.drawable.sample_4,
    };

    private DisplayManager mDisplayManager;
    private DisplayListAdapter mDisplayListAdapter;
    private CheckBox mShowAllDisplaysCheckbox;
    private ListView mListView;
    private int mNextImageNumber;

    // List of presentation contents indexed by displayId.
    // This state persists so that we can restore the old presentation
    // contents when the activity is paused or resumed.
    private SparseArray&lt;PresentationContents&gt; mSavedPresentationContents;

    // List of all currently visible presentations indexed by display id.
    private final SparseArray&lt;DemoPresentation&gt; mActivePresentations =
            new SparseArray&lt;DemoPresentation&gt;();

    /**
     * Initialization of the Activity after it is first created.  Must at least
     * call {@link android.app.Activity#setContentView setContentView()} to
     * describe what is to be displayed in the screen.
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // Be sure to call the super class.
        super.onCreate(savedInstanceState);

        // Restore saved instance state.
        if (savedInstanceState != null) {
            mSavedPresentationContents =
                    savedInstanceState.getSparseParcelableArray(PRESENTATION_KEY);
        } else {
            mSavedPresentationContents = new SparseArray&lt;PresentationContents&gt;();
        }

        // Get the display manager service.
        mDisplayManager = (DisplayManager)getSystemService(Context.DISPLAY_SERVICE);

        // See assets/res/any/layout/presentation_activity.xml for this
        // view layout definition, which is being set here as
        // the content of our screen.
        setContentView(R.layout.presentation_activity);

        // Set up checkbox to toggle between showing all displays or only presentation displays.
        mShowAllDisplaysCheckbox = (CheckBox)findViewById(R.id.show_all_displays);
        mShowAllDisplaysCheckbox.setOnCheckedChangeListener(this);

        // Set up the list of displays.
        mDisplayListAdapter = new DisplayListAdapter(this);
        mListView = (ListView)findViewById(R.id.display_list);
        mListView.setAdapter(mDisplayListAdapter);
    }

    @Override
    protected void onResume() {
        // Be sure to call the super class.
        super.onResume();

        // Update our list of displays on resume.
        mDisplayListAdapter.updateContents();

        // Restore presentations from before the activity was paused.
        final int numDisplays = mDisplayListAdapter.getCount();
        for (int i = 0; i &lt; numDisplays; i++) {
            final Display display = mDisplayListAdapter.getItem(i);
            final PresentationContents contents =
                    mSavedPresentationContents.get(display.getDisplayId());
            if (contents != null) {
                showPresentation(display, contents);
            }
        }
        mSavedPresentationContents.clear();

        // Register to receive events from the display manager.
        mDisplayManager.registerDisplayListener(mDisplayListener, null);
    }

    @Override
    protected void onPause() {
        // Be sure to call the super class.
        super.onPause();

        // Unregister from the display manager.
        mDisplayManager.unregisterDisplayListener(mDisplayListener);

        // Dismiss all of our presentations but remember their contents.
        Log.d(TAG, "Activity is being paused.  Dismissing all active presentation.");
        for (int i = 0; i &lt; mActivePresentations.size(); i++) {
            DemoPresentation presentation = mActivePresentations.valueAt(i);
            int displayId = mActivePresentations.keyAt(i);
            mSavedPresentationContents.put(displayId, presentation.mContents);
            presentation.dismiss();
        }
        mActivePresentations.clear();
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        // Be sure to call the super class.
        super.onSaveInstanceState(outState);
        outState.putSparseParcelableArray(PRESENTATION_KEY, mSavedPresentationContents);
    }

    /**
     * Shows a {@link Presentation} on the specified display.
     */
    private void showPresentation(Display display, PresentationContents contents) {
        final int displayId = display.getDisplayId();
        if (mActivePresentations.get(displayId) != null) {
            return;
        }

        Log.d(TAG, "Showing presentation photo #" + contents.photo
                + " on display #" + displayId + ".");

        DemoPresentation presentation = new DemoPresentation(this, display, contents);
        presentation.show();
        presentation.setOnDismissListener(mOnDismissListener);
        mActivePresentations.put(displayId, presentation);
    }

    /**
     * Hides a {@link Presentation} on the specified display.
     */
    private void hidePresentation(Display display) {
        final int displayId = display.getDisplayId();
        DemoPresentation presentation = mActivePresentations.get(displayId);
        if (presentation == null) {
            return;
        }

        Log.d(TAG, "Dismissing presentation on display #" + displayId + ".");

        presentation.dismiss();
        mActivePresentations.delete(displayId);
    }

    private int getNextPhoto() {
        final int photo = mNextImageNumber;
        mNextImageNumber = (mNextImageNumber + 1) % PHOTOS.length;
        return photo;
    }

    /**
     * Called when the show all displays checkbox is toggled or when
     * an item in the list of displays is checked or unchecked.
     */
    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        if (buttonView == mShowAllDisplaysCheckbox) {
            // Show all displays checkbox was toggled.
            mDisplayListAdapter.updateContents();
        } else {
            // Display item checkbox was toggled.
            final Display display = (Display)buttonView.getTag();
            if (isChecked) {
                PresentationContents contents = new PresentationContents(getNextPhoto());
                showPresentation(display, contents);
            } else {
                hidePresentation(display);
            }
        }
    }

    /**
     * Called when the Info button next to a display is clicked to show information
     * about the display.
     */
    @Override
    public void onClick(View v) {
        Context context = v.getContext();
        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        final Display display = (Display)v.getTag();
        Resources r = context.getResources();
        AlertDialog alert = builder
                .setTitle(r.getString(
                        R.string.presentation_alert_info_text, display.getDisplayId()))
                .setMessage(display.toString())
                .setNeutralButton(R.string.presentation_alert_dismiss_text,
                        new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                dialog.dismiss();
                            }
                    })
                .create();
        alert.show();
    }

    /**
     * Listens for displays to be added, changed or removed.
     * We use it to update the list and show a new {@link Presentation} when a
     * display is connected.
     *
     * Note that we don't bother dismissing the {@link Presentation} when a
     * display is removed, although we could.  The presentation API takes care
     * of doing that automatically for us.
     */
    private final DisplayManager.DisplayListener mDisplayListener =
            new DisplayManager.DisplayListener() {
        @Override
        public void onDisplayAdded(int displayId) {
            Log.d(TAG, "Display #" + displayId + " added.");
            mDisplayListAdapter.updateContents();
        }

        @Override
        public void onDisplayChanged(int displayId) {
            Log.d(TAG, "Display #" + displayId + " changed.");
            mDisplayListAdapter.updateContents();
        }

        @Override
        public void onDisplayRemoved(int displayId) {
            Log.d(TAG, "Display #" + displayId + " removed.");
            mDisplayListAdapter.updateContents();
        }
    };

    /**
     * Listens for when presentations are dismissed.
     */
    private final DialogInterface.OnDismissListener mOnDismissListener =
            new DialogInterface.OnDismissListener() {
        @Override
        public void onDismiss(DialogInterface dialog) {
            DemoPresentation presentation = (DemoPresentation)dialog;
            int displayId = presentation.getDisplay().getDisplayId();
            Log.d(TAG, "Presentation on display #" + displayId + " was dismissed.");
            mActivePresentations.delete(displayId);
            mDisplayListAdapter.notifyDataSetChanged();
        }
    };

    /**
     * List adapter.
     * Shows information about all displays.
     */
    private final class DisplayListAdapter extends ArrayAdapter&lt;Display&gt; {
        final Context mContext;

        public DisplayListAdapter(Context context) {
            super(context, R.layout.presentation_list_item);
            mContext = context;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            final View v;
            if (convertView == null) {
                v = ((Activity) mContext).getLayoutInflater().inflate(
                        R.layout.presentation_list_item, null);
            } else {
                v = convertView;
            }

            final Display display = getItem(position);
            final int displayId = display.getDisplayId();

            CheckBox cb = (CheckBox)v.findViewById(R.id.checkbox_presentation);
            cb.setTag(display);
            cb.setOnCheckedChangeListener(PresentationActivity.this);
            cb.setChecked(mActivePresentations.indexOfKey(displayId) &gt;= 0
                    || mSavedPresentationContents.indexOfKey(displayId) &gt;= 0);

            TextView tv = (TextView)v.findViewById(R.id.display_id);
            tv.setText(v.getContext().getResources().getString(
                    R.string.presentation_display_id_text, displayId, display.getName()));

            Button b = (Button)v.findViewById(R.id.info);
            b.setTag(display);
            b.setOnClickListener(PresentationActivity.this);

            return v;
        }

        /**
         * Update the contents of the display list adapter to show
         * information about all current displays.
         */
        public void updateContents() {
            clear();

            String displayCategory = getDisplayCategory();
            Display[] displays = mDisplayManager.getDisplays(displayCategory);
            addAll(displays);

            Log.d(TAG, "There are currently " + displays.length + " displays connected.");
            for (Display display : displays) {
                Log.d(TAG, "  " + display);
            }
        }

        private String getDisplayCategory() {
            return mShowAllDisplaysCheckbox.isChecked() ? null :
                DisplayManager.DISPLAY_CATEGORY_PRESENTATION;
        }
    }

    /**
     * The presentation to show on the secondary display.
     *
     * Note that the presentation display may have different metrics from the display on which
     * the main activity is showing so we must be careful to use the presentation's
     * own {@link Context} whenever we load resources.
     */
    private final class DemoPresentation extends Presentation {

        final PresentationContents mContents;

        public DemoPresentation(Context context, Display display, PresentationContents contents) {
            super(context, display);
            mContents = contents;
        }

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            // Be sure to call the super class.
            super.onCreate(savedInstanceState);

            // Get the resources for the context of the presentation.
            // Notice that we are getting the resources from the context of the presentation.
            Resources r = getContext().getResources();

            // Inflate the layout.
            setContentView(R.layout.presentation_content);

            final Display display = getDisplay();
            final int displayId = display.getDisplayId();
            final int photo = mContents.photo;

            // Show a caption to describe what's going on.
            TextView text = (TextView)findViewById(R.id.text);
            text.setText(r.getString(R.string.presentation_photo_text,
                    photo, displayId, display.getName()));

            // Show a n image for visual interest.
            ImageView image = (ImageView)findViewById(R.id.image);
            image.setImageDrawable(r.getDrawable(PHOTOS[photo]));

            GradientDrawable drawable = new GradientDrawable();
            drawable.setShape(GradientDrawable.RECTANGLE);
            drawable.setGradientType(GradientDrawable.RADIAL_GRADIENT);

            // Set the background to a random gradient.
            Point p = new Point();
            getDisplay().getSize(p);
            drawable.setGradientRadius(Math.max(p.x, p.y) / 2);
            drawable.setColors(mContents.colors);
            findViewById(android.R.id.content).setBackground(drawable);
        }
    }

    /**
     * Information about the content we want to show in a presentation.
     */
    private final static class PresentationContents implements Parcelable {
        final int photo;
        final int[] colors;

        public static final Creator&lt;PresentationContents&gt; CREATOR =
                new Creator&lt;PresentationContents&gt;() {
            @Override
            public PresentationContents createFromParcel(Parcel in) {
                return new PresentationContents(in);
            }

            @Override
            public PresentationContents[] newArray(int size) {
                return new PresentationContents[size];
            }
        };

        public PresentationContents(int photo) {
            this.photo = photo;
            colors = new int[] {
                    ((int) (Math.random() * Integer.MAX_VALUE)) | 0xFF000000,
                    ((int) (Math.random() * Integer.MAX_VALUE)) | 0xFF000000 };
        }

        private PresentationContents(Parcel in) {
            photo = in.readInt();
            colors = new int[] { in.readInt(), in.readInt() };
        }

        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            dest.writeInt(photo);
            dest.writeInt(colors[0]);
            dest.writeInt(colors[1]);
        }
    }
}</code></example></para>
      <para tool="javadoc-to-mdoc">
 A presentation is a special kind of dialog whose purpose is to present
 content on a secondary display.  A <c><see cref="T:Android.App.Presentation" /></c> is associated with
 the target <c><see cref="T:Android.Views.Display" /></c> at creation time and configures its context and
 resource configuration according to the display's metrics.
 </para>
      <para tool="javadoc-to-mdoc">
 Notably, the <c><see cref="T:Android.Content.Context" /></c> of a presentation is different from the context
 of its containing <c><see cref="T:Android.App.Activity" /></c>.  It is important to inflate the layout
 of a presentation and load other resources using the presentation's own context
 to ensure that assets of the correct size and density for the target display
 are loaded.
 </para>
      <para tool="javadoc-to-mdoc">
 A presentation is automatically canceled (see <c><see cref="M:Android.App.Dialog.Cancel" /></c>) when
 the display to which it is attached is removed.  An activity should take
 care of pausing and resuming whatever content is playing within the presentation
 whenever the activity itself is paused or resumed.
 </para>
      <para tool="javadoc-to-mdoc">
 Before showing a <c><see cref="T:Android.App.Presentation" /></c> it's important to choose the <c><see cref="T:Android.Views.Display" /></c>
 on which it will appear.  Choosing a presentation display is sometimes difficult
 because there may be multiple displays attached.  Rather than trying to guess
 which display is best, an application should let the system choose a suitable
 presentation display.
 </para>
      <para tool="javadoc-to-mdoc">
 There are two main ways to choose a <c><see cref="T:Android.Views.Display" /></c>.
 </para>
      <para tool="javadoc-to-mdoc">
 The easiest way to choose a presentation display is to use the
 <c><see cref="T:Android.Media.MediaRouter" /></c> API.  The media router service keeps
 track of which audio and video routes are available on the system.
 The media router sends notifications whenever routes are selected or unselected
 or when the preferred presentation display of a route changes.
 So an application can simply watch for these notifications and show or dismiss
 a presentation on the preferred presentation display automatically.
 </para>
      <para tool="javadoc-to-mdoc">
 The preferred presentation display is the display that the media router recommends
 that the application should use if it wants to show content on the secondary display.
 Sometimes there may not be a preferred presentation display in which
 case the application should show its content locally without using a presentation.
 </para>
      <para tool="javadoc-to-mdoc">
 Here's how to use the media router to create and show a presentation on the preferred
 presentation display using <c><see cref="!:NoType:android/media/MediaRouter$RouteInfo;Href=../../../reference/android/media/MediaRouter.RouteInfo.html#getPresentationDisplay()" /></c>.
 </para>
      <para tool="javadoc-to-mdoc">
 The following sample code from <c>ApiDemos</c> demonstrates how to use the media
 router to automatically switch between showing content in the main activity and showing
 the content in a presentation when a presentation display is available.
 </para>
      <para tool="javadoc-to-mdoc">
 Another way to choose a presentation display is to use the <c><see cref="T:Android.Hardware.Display.DisplayManager" /></c> API
 directly.  The display manager service provides functions to enumerate and describe all
 displays that are attached to the system including displays that may be used
 for presentations.
 </para>
      <para tool="javadoc-to-mdoc">
 The display manager keeps track of all displays in the system.  However, not all
 displays are appropriate for showing presentations.  For example, if an activity
 attempted to show a presentation on the main display it might obscure its own content
 (it's like opening a dialog on top of your activity).
 </para>
      <para tool="javadoc-to-mdoc">
 Here's how to identify suitable displays for showing presentations using
 <c><see cref="M:Android.Hardware.Display.DisplayManager.GetDisplays(System.String)" /></c> and the
 <c><see cref="F:Android.Hardware.Display.DisplayManager.DisplayCategoryPresentation" /></c> category.
 </para>
      <para tool="javadoc-to-mdoc">
 The following sample code from <c>ApiDemos</c> demonstrates how to use the display
 manager to enumerate displays and show content on multiple presentation displays
 simultaneously.
 </para>
      <format type="text/html">
        <h5 class="jd-tagtitle">See Also</h5>
      </format>
      <list type="bullet">
        <item>
          <term>
            <c>
              <see cref="F:Android.Media.MediaRouter.RouteTypeLiveVideo" />
            </c>
          </term>
        </item>
        <item>
          <term>
            <c>
              <see cref="T:Android.Hardware.Display.DisplayManager" />
            </c>
          </term>
        </item>
      </list>
      <para tool="javadoc-to-mdoc">
        <format type="text/html">
          <a href="http://developer.android.com/reference/android/app/Presentation.html" target="_blank">[Android Documentation]</a>
        </format>
      </para>
    </remarks>
    <since version="Added in API level 17" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Presentation (Android.Content.Context outerContext, Android.Views.Display display);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Android.Content.Context outerContext, class Android.Views.Display display) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(Landroid/content/Context;Landroid/view/Display;)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="outerContext" Type="Android.Content.Context" />
        <Parameter Name="display" Type="Android.Views.Display" />
      </Parameters>
      <Docs>
        <param name="outerContext">To be added.</param>
        <param name="display">To be added.</param>
        <summary>Creates a new presentation that is attached to the specified display
 using the default theme.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Creates a new presentation that is attached to the specified display
 using the default theme.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Presentation.html#Presentation(android.content.Context, android.view.Display)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 17" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Presentation (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This constructor is invoked by the runtime infrastructure (<see cref="M:Java.Lang.Object.GetObject{T}(System.IntPtr,Android.Runtime.JniHandleOwnership)" />) to create a new managed representation for a Java Native Interface object.</para>
          <para tool="javadoc-to-mdoc">The constructor will initializes the <see cref="P:Android.Runtime.IJavaObject.Handle" /> property of the new instance using <paramref name="javaReference" /> and <paramref name="transfer" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Presentation (Android.Content.Context outerContext, Android.Views.Display display, int theme);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Android.Content.Context outerContext, class Android.Views.Display display, int32 theme) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(Landroid/content/Context;Landroid/view/Display;I)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="outerContext" Type="Android.Content.Context" />
        <Parameter Name="display" Type="Android.Views.Display" />
        <Parameter Name="theme" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="outerContext">To be added.</param>
        <param name="display">To be added.</param>
        <param name="theme">To be added.</param>
        <summary>Creates a new presentation that is attached to the specified display
 using the optionally specified theme.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Creates a new presentation that is attached to the specified display
 using the optionally specified theme.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Presentation.html#Presentation(android.content.Context, android.view.Display, int)" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 17" />
      </Docs>
    </Member>
    <Member MemberName="Display">
      <MemberSignature Language="C#" Value="public virtual Android.Views.Display Display { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Android.Views.Display Display" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getDisplay", "()Landroid/view/Display;", "GetGetDisplayHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.Views.Display</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <c><see cref="T:Android.Views.Display" /></c> that this presentation appears on.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Gets the <c><see cref="T:Android.Views.Display" /></c> that this presentation appears on.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Presentation.html#getDisplay()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 17" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayChanged">
      <MemberSignature Language="C#" Value="public virtual void OnDisplayChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDisplayChanged() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onDisplayChanged", "()V", "GetOnDisplayChangedHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called by the system when the properties of the <c><see cref="T:Android.Views.Display" /></c> to which
 the presentation is attached have changed.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Called by the system when the properties of the <c><see cref="T:Android.Views.Display" /></c> to which
 the presentation is attached have changed.

 If the display metrics have changed (for example, if the display has been
 resized or rotated), then the system automatically calls
 <c><see cref="M:Android.App.Dialog.Cancel" /></c> to dismiss the presentation.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Presentation.html#onDisplayChanged()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 17" />
        <altmember cref="P:Android.App.Presentation.Display" />
      </Docs>
    </Member>
    <Member MemberName="OnDisplayRemoved">
      <MemberSignature Language="C#" Value="public virtual void OnDisplayRemoved ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDisplayRemoved() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("onDisplayRemoved", "()V", "GetOnDisplayRemovedHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Called by the system when the <c><see cref="T:Android.Views.Display" /></c> to which the presentation
 is attached has been removed.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">Called by the system when the <c><see cref="T:Android.Views.Display" /></c> to which the presentation
 is attached has been removed.

 The system automatically calls <c><see cref="M:Android.App.Dialog.Cancel" /></c> to dismiss the presentation
 after sending this event.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Presentation.html#onDisplayRemoved()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 17" />
        <altmember cref="P:Android.App.Presentation.Display" />
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public virtual Android.Content.Res.Resources Resources { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Android.Content.Res.Resources Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getResources", "()Landroid/content/res/Resources;", "GetGetResourcesHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Android.Content.Res.Resources</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <c><see cref="T:Android.Content.Res.Resources" /></c> that should be used to inflate the layout of this presentation.</summary>
        <value>To be added.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">Gets the <c><see cref="T:Android.Content.Res.Resources" /></c> that should be used to inflate the layout of this presentation.
 This resources object has been configured according to the metrics of the
 display that the presentation appears on.</para>
          <para tool="javadoc-to-mdoc">
            <format type="text/html">
              <a href="http://developer.android.com/reference/android/app/Presentation.html#getResources()" target="_blank">[Android Documentation]</a>
            </format>
          </para>
        </remarks>
        <since version="Added in API level 17" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonvirtualVoidMethod" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
