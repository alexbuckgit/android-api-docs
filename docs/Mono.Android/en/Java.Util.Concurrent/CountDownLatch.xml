<Type Name="CountDownLatch" FullName="Java.Util.Concurrent.CountDownLatch">
  <TypeSignature Language="C#" Value="public class CountDownLatch : Java.Lang.Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CountDownLatch extends Java.Lang.Object" />
  <AssemblyInfo>
    <AssemblyName>Mono.Android</AssemblyName>
    <AssemblyVersion>0.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>Java.Lang.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Android.Runtime.Register("java/util/concurrent/CountDownLatch", DoNotGenerateAcw=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A synchronization aid that allows one or more threads to wait until
 a set of operations being performed in other threads completes.</summary>
    <remarks><para tool="javadoc-to-mdoc">A synchronization aid that allows one or more threads to wait until
 a set of operations being performed in other threads completes.

 </para><para tool="javadoc-to-mdoc">A <c>CountDownLatch</c> is initialized with a given <i>count</i>.
 The <c><see cref="M:Java.Util.Concurrent.CountDownLatch.Await" /></c> methods block until the current count reaches
 zero due to invocations of the <c><see cref="M:Java.Util.Concurrent.CountDownLatch.CountDown" /></c> method, after which
 all waiting threads are released and any subsequent invocations of
 <c><see cref="M:Java.Util.Concurrent.CountDownLatch.Await" /></c> return immediately.  This is a one-shot phenomenon
 -- the count cannot be reset.  If you need a version that resets the
 count, consider using a <c><see cref="T:Java.Util.Concurrent.CyclicBarrier" /></c>.

 </para><para tool="javadoc-to-mdoc">A <c>CountDownLatch</c> is a versatile synchronization tool
 and can be used for a number of purposes.  A
 <c>CountDownLatch</c> initialized with a count of one serves as a
 simple on/off latch, or gate: all threads invoking <c><see cref="M:Java.Util.Concurrent.CountDownLatch.Await" /></c>
 wait at the gate until it is opened by a thread invoking <c><see cref="M:Java.Util.Concurrent.CountDownLatch.CountDown" /></c>.  A <c>CountDownLatch</c> initialized to <i>N</i>
 can be used to make one thread wait until <i>N</i> threads have
 completed some action, or some action has been completed N times.

 </para><para tool="javadoc-to-mdoc">A useful property of a <c>CountDownLatch</c> is that it
 doesn't require that threads calling <c>countDown</c> wait for
 the count to reach zero before proceeding, it simply prevents any
 thread from proceeding past an <c><see cref="M:Java.Util.Concurrent.CountDownLatch.Await" /></c> until all
 threads could pass.

 </para><para tool="javadoc-to-mdoc"><format type="text/html"><b>Sample usage:</b></format> Here is a pair of classes in which a group
 of worker threads use two countdown latches:
 <list type="bullet"><item><term>The first is a start signal that prevents any worker from proceeding
 until the driver is ready for them to proceed;
 </term></item><item><term>The second is a completion signal that allows the driver to wait
 until all workers have completed.
 </term></item></list><sample external-id="247D028BC1385A42689384A30AD21283" /></para><para tool="javadoc-to-mdoc">Another typical usage would be to divide a problem into N parts,
 describe each part with a Runnable that executes that portion and
 counts down on the latch, and queue all the Runnables to an
 Executor.  When all sub-parts are complete, the coordinating thread
 will be able to pass through await. (When threads must repeatedly
 count down in this way, instead use a <c><see cref="T:Java.Util.Concurrent.CyclicBarrier" /></c>.)

  <sample external-id="57C8F895A007E4D71CBFAD1D744E9D61" /></para><para tool="javadoc-to-mdoc">Memory consistency effects: Until the count reaches
 zero, actions in a thread prior to calling
 <c>countDown()</c>
 actions following a successful return from a corresponding
 <c>await()</c> in another thread.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/CountDownLatch.html" target="_blank">[Android Documentation]</a></format></para></remarks>
    <since version="Added in API level 1" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CountDownLatch (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 count) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register(".ctor", "(I)V", "")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">To be added.</param>
        <summary>Constructs a <c>CountDownLatch</c> initialized with the given count.</summary>
        <remarks><para tool="javadoc-to-mdoc">Constructs a <c>CountDownLatch</c> initialized with the given count.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/CountDownLatch.html#CountDownLatch(int)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.IllegalArgumentException">if <c>count</c> is negative
</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CountDownLatch (IntPtr javaReference, Android.Runtime.JniHandleOwnership transfer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int javaReference, valuetype Android.Runtime.JniHandleOwnership transfer) cil managed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="javaReference" Type="System.IntPtr" />
        <Parameter Name="transfer" Type="Android.Runtime.JniHandleOwnership" />
      </Parameters>
      <Docs>
        <param name="javaReference">A <see cref="T:System.IntPtr" />containing a Java Native Interface (JNI) object reference.</param>
        <param name="transfer">A <see cref="T:Android.Runtime.JniHandleOwnership" />indicating how to handle <paramref name="javaReference" /></param>
        <summary>A constructor used when creating managed representations of JNI objects; called by the runtime.</summary>
        <remarks>
          <para tool="javadoc-to-mdoc">This constructor is invoked by the runtime infrastructure (<see cref="M:Java.Lang.Object.GetObject``1(System.IntPtr,Android.Runtime.JniHandleOwnership)" />) to create a new managed representation for a Java Native Interface object.</para>
          <para tool="javadoc-to-mdoc">The constructor will initializes the <see cref="P:Android.Runtime.IJavaObject.Handle" /> property of the new instance using <paramref name="javaReference" /> and <paramref name="transfer" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Await">
      <MemberSignature Language="C#" Value="public virtual void Await ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Await() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("await", "()V", "GetAwaitHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causes the current thread to wait until the latch has counted down to
 zero, unless the thread is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>.</summary>
        <remarks><para tool="javadoc-to-mdoc">Causes the current thread to wait until the latch has counted down to
 zero, unless the thread is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>.

 </para><para tool="javadoc-to-mdoc">If the current count is zero then this method returns immediately.

 </para><para tool="javadoc-to-mdoc">If the current count is greater than zero then the current
 thread becomes disabled for thread scheduling purposes and lies
 dormant until one of two things happen:
 <list type="bullet"><item><term>The count reaches zero due to invocations of the
 <c><see cref="M:Java.Util.Concurrent.CountDownLatch.CountDown" /></c> method; or
 </term></item><item><term>Some other thread <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>
 the current thread.
 </term></item></list></para><para tool="javadoc-to-mdoc">If the current thread:
 <list type="bullet"><item><term>has its interrupted status set on entry to this method; or
 </term></item><item><term>is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> while waiting,
 </term></item></list>
 then <c><see cref="T:Java.Lang.InterruptedException" /></c> is thrown and the current thread's
 interrupted status is cleared.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/CountDownLatch.html#await()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.InterruptedException">if the current thread is interrupted
         while waiting
</exception>
      </Docs>
    </Member>
    <Member MemberName="Await">
      <MemberSignature Language="C#" Value="public virtual bool Await (long timeout, Java.Util.Concurrent.TimeUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Await(int64 timeout, class Java.Util.Concurrent.TimeUnit unit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("await", "(JLjava/util/concurrent/TimeUnit;)Z", "GetAwait_JLjava_util_concurrent_TimeUnit_Handler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
      </Parameters>
      <Docs>
        <param name="timeout">the maximum time to wait</param>
        <param name="unit">the time unit of the <c>timeout</c> argument</param>
        <summary>Causes the current thread to wait until the latch has counted down to
 zero, unless the thread is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>,
 or the specified waiting time elapses.</summary>
        <returns>To be added.</returns>
        <remarks><para tool="javadoc-to-mdoc">Causes the current thread to wait until the latch has counted down to
 zero, unless the thread is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>,
 or the specified waiting time elapses.

 </para><para tool="javadoc-to-mdoc">If the current count is zero then this method returns immediately
 with the value <c>true</c>.

 </para><para tool="javadoc-to-mdoc">If the current count is greater than zero then the current
 thread becomes disabled for thread scheduling purposes and lies
 dormant until one of three things happen:
 <list type="bullet"><item><term>The count reaches zero due to invocations of the
 <c><see cref="M:Java.Util.Concurrent.CountDownLatch.CountDown" /></c> method; or
 </term></item><item><term>Some other thread <c><see cref="M:Java.Lang.Thread.Interrupt" /></c>
 the current thread; or
 </term></item><item><term>The specified waiting time elapses.
 </term></item></list></para><para tool="javadoc-to-mdoc">If the count reaches zero then the method returns with the
 value <c>true</c>.

 </para><para tool="javadoc-to-mdoc">If the current thread:
 <list type="bullet"><item><term>has its interrupted status set on entry to this method; or
 </term></item><item><term>is <c><see cref="M:Java.Lang.Thread.Interrupt" /></c> while waiting,
 </term></item></list>
 then <c><see cref="T:Java.Lang.InterruptedException" /></c> is thrown and the current thread's
 interrupted status is cleared.

 </para><para tool="javadoc-to-mdoc">If the specified waiting time elapses then the value <c>false</c>
 is returned.  If the time is less than or equal to zero, the method
 will not wait at all.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/CountDownLatch.html#await(long, java.util.concurrent.TimeUnit)" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
        <exception cref="T:Java.Lang.InterruptedException">if the current thread is interrupted
         while waiting
</exception>
      </Docs>
    </Member>
    <Member MemberName="AwaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task AwaitAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task AwaitAsync() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AwaitAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;bool&gt; AwaitAsync (long timeout, Java.Util.Concurrent.TimeUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;bool&gt; AwaitAsync(int64 timeout, class Java.Util.Concurrent.TimeUnit unit) cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int64" />
        <Parameter Name="unit" Type="Java.Util.Concurrent.TimeUnit" />
      </Parameters>
      <Docs>
        <param name="timeout">To be added.</param>
        <param name="unit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual long Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: Android.Runtime.Register("getCount", "()J", "GetGetCountHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the current count.</summary>
        <value>To be added.</value>
        <remarks><para tool="javadoc-to-mdoc">Returns the current count.

 </para><para tool="javadoc-to-mdoc">This method is typically used for debugging and testing purposes.</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/CountDownLatch.html#getCount()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="CountDown">
      <MemberSignature Language="C#" Value="public virtual void CountDown ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CountDown() cil managed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Android.Runtime.Register("countDown", "()V", "GetCountDownHandler")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Decrements the count of the latch, releasing all waiting threads if
 the count reaches zero.</summary>
        <remarks><para tool="javadoc-to-mdoc">Decrements the count of the latch, releasing all waiting threads if
 the count reaches zero.

 </para><para tool="javadoc-to-mdoc">If the current count is greater than zero then it is decremented.
 If the new count is zero then all waiting threads are re-enabled for
 thread scheduling purposes.

 </para><para tool="javadoc-to-mdoc">If the current count equals zero then nothing happens.
</para><para tool="javadoc-to-mdoc"><format type="text/html"><a href="http://developer.android.com/reference/java/util/concurrent/CountDownLatch.html#countDown()" target="_blank">[Android Documentation]</a></format></para></remarks>
        <since version="Added in API level 1" />
      </Docs>
    </Member>
    <Member MemberName="ThresholdClass">
      <MemberSignature Language="C#" Value="protected override IntPtr ThresholdClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ThresholdClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.IntPtr" /> which contains the <c>java.lang.Class</c> JNI value corresponding to this type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control which <c>jclass</c> is provided to methods like <see cref="M:Android.Runtime.JNIEnv.CallNonVirtualVoidMethod" />.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThresholdType">
      <MemberSignature Language="C#" Value="protected override Type ThresholdType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ThresholdType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyVersion>0.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>This API supports the Mono for Android infrastructure and is not intended to be used directly from your code.</summary>
        <value>A <see cref="T:System.Type" /> which provides the declaring type.</value>
        <remarks>
          <para tool="javadoc-to-mdoc">This property is used to control virtual vs. non virtual method dispatch against the underlying JNI object. When this property is equal to the declaring type, then virtual method invocation against the JNI object is performed; otherwise, we assume that the method was overridden by a derived type, and perform non-virtual methdo invocation.</para>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
