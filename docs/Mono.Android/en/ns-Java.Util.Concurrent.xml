<Namespace Name="Java.Util.Concurrent">
  <Docs>
    <summary><format type="text/html"><b>Implementations.</b></format>

 Classes <c><see cref="T:Java.Util.Concurrent.ThreadPoolExecutor" /></c> and
 <c><see cref="T:Java.Util.Concurrent.ScheduledThreadPoolExecutor" /></c>
 provide tunable, flexible thread pools.</summary>
    <remarks>
    Utility classes commonly useful in concurrent programming.  This
 package includes a few small standardized extensible frameworks, as
 well as some classes that provide useful functionality and are
 otherwise tedious or difficult to implement.  Here are brief
 descriptions of the main components.  See also the
 <c><see cref="N:Java.Util.Concurrent.Locks" /></c> and
 <c><see cref="N:Java.Util.Concurrent.Atomic" /></c> packages.

 <format type="text/html"><h2>Executors</h2></format><format type="text/html"><b>Interfaces.</b></format><c><see cref="T:Java.Util.Concurrent.IExecutor" /></c> is a simple standardized
 interface for defining custom thread-like subsystems, including
 thread pools, asynchronous I/O, and lightweight task frameworks.
 Depending on which concrete Executor class is being used, tasks may
 execute in a newly created thread, an existing task-execution thread,
 or the thread calling <c><see cref="M:Java.Util.Concurrent.IExecutor.Execute(Java.Lang.IRunnable)" /></c>, and may execute sequentially or concurrently.

 <c><see cref="T:Java.Util.Concurrent.IExecutorService" /></c> provides a more
 complete asynchronous task execution framework.  An
 ExecutorService manages queuing and scheduling of tasks,
 and allows controlled shutdown.

 The <c><see cref="T:Java.Util.Concurrent.IScheduledExecutorService" /></c>
 subinterface and associated interfaces add support for
 delayed and periodic task execution.  ExecutorServices
 provide methods arranging asynchronous execution of any
 function expressed as <c><see cref="T:Java.Util.Concurrent.ICallable" /></c>,
 the result-bearing analog of <c><see cref="T:Java.Lang.IRunnable" /></c>.

 A <c><see cref="T:Java.Util.Concurrent.IFuture" /></c> returns the results of
 a function, allows determination of whether execution has
 completed, and provides a means to cancel execution.

 A <c><see cref="T:Java.Util.Concurrent.IRunnableFuture" /></c> is a <c>Future</c>
 that possesses a <c>run</c> method that upon execution,
 sets its results.

 <para tool="javadoc-to-mdoc"><format type="text/html"><b>Implementations.</b></format>

 Classes <c><see cref="T:Java.Util.Concurrent.ThreadPoolExecutor" /></c> and
 <c><see cref="T:Java.Util.Concurrent.ScheduledThreadPoolExecutor" /></c>
 provide tunable, flexible thread pools.

 The <c><see cref="T:Java.Util.Concurrent.Executors" /></c> class provides
 factory methods for the most common kinds and configurations
 of Executors, as well as a few utility methods for using
 them.  Other utilities based on <c>Executors</c> include the
 concrete class <c><see cref="T:Java.Util.Concurrent.FutureTask" /></c>
 providing a common extensible implementation of Futures, and
 <c><see cref="T:Java.Util.Concurrent.ExecutorCompletionService" /></c>, that
 assists in coordinating the processing of groups of
 asynchronous tasks.

 <format type="text/html"><h2>Queues</h2></format>

 The <c><see cref="T:Java.Util.Concurrent.ConcurrentLinkedQueue" /></c> class
 supplies an efficient scalable thread-safe non-blocking FIFO
 queue.

 </para><para tool="javadoc-to-mdoc">Five implementations in <c>java.util.concurrent</c> support
 the extended <c><see cref="T:Java.Util.Concurrent.IBlockingQueue" /></c>
 interface, that defines blocking versions of put and take:
 <c><see cref="T:Java.Util.Concurrent.LinkedBlockingQueue" /></c>,
 <c><see cref="T:Java.Util.Concurrent.ArrayBlockingQueue" /></c>,
 <c><see cref="T:Java.Util.Concurrent.SynchronousQueue" /></c>,
 <c><see cref="T:Java.Util.Concurrent.PriorityBlockingQueue" /></c>, and
 <c><see cref="T:Java.Util.Concurrent.DelayQueue" /></c>.
 The different classes cover the most common usage contexts
 for producer-consumer, messaging, parallel tasking, and
 related concurrent designs.

 </para><para tool="javadoc-to-mdoc">The <c><see cref="T:Java.Util.Concurrent.IBlockingDeque" /></c> interface
 extends <c>BlockingQueue</c> to support both FIFO and LIFO
 (stack-based) operations.
 Class <c><see cref="T:Java.Util.Concurrent.LinkedBlockingDeque" /></c>
 provides an implementation.

 <format type="text/html"><h2>Timing</h2></format>

 The <c><see cref="T:Java.Util.Concurrent.TimeUnit" /></c> class provides
 multiple granularities (including nanoseconds) for
 specifying and controlling time-out based operations.  Most
 classes in the package contain operations based on time-outs
 in addition to indefinite waits.  In all cases that
 time-outs are used, the time-out specifies the minimum time
 that the method should wait before indicating that it
 timed-out.  Implementations make a "best effort"
 to detect time-outs as soon as possible after they occur.
 However, an indefinite amount of time may elapse between a
 time-out being detected and a thread actually executing
 again after that time-out.  All methods that accept timeout
 parameters treat values less than or equal to zero to mean
 not to wait at all.  To wait "forever", you can use a value
 of <c>Long.MAX_VALUE</c>.

 <format type="text/html"><h2>Synchronizers</h2></format>

 Four classes aid common special-purpose synchronization idioms.
 <list type="bullet"><item><term><c><see cref="T:Java.Util.Concurrent.Semaphore" /></c> is a classic concurrency tool.

 </term></item><item><term><c><see cref="T:Java.Util.Concurrent.CountDownLatch" /></c> is a very simple yet
 very common utility for blocking until a given number of signals,
 events, or conditions hold.

 </term></item><item><term>A <c><see cref="T:Java.Util.Concurrent.CyclicBarrier" /></c> is a resettable
 multiway synchronization point useful in some styles of parallel
 programming.

 </term></item><item><term>An <c><see cref="T:Java.Util.Concurrent.Exchanger" /></c> allows two threads to
 exchange objects at a rendezvous point, and is useful in several
 pipeline designs.

 </term></item></list><format type="text/html"><h2>Concurrent Collections</h2></format>

 Besides Queues, this package supplies Collection implementations
 designed for use in multithreaded contexts:
 <c><see cref="T:Java.Util.Concurrent.ConcurrentHashMap" /></c>,
 <c><see cref="T:Java.Util.Concurrent.ConcurrentSkipListMap" /></c>,
 <c><see cref="!:NoType:java/util/concurrent/ConcurrentSkipListSet;Href=../../../../reference/java/util/concurrent/ConcurrentSkipListSet.html" /></c>,
 <c><see cref="T:Java.Util.Concurrent.CopyOnWriteArrayList" /></c>, and
 <c><see cref="T:Java.Util.Concurrent.CopyOnWriteArraySet" /></c>.
 When many threads are expected to access a given collection, a
 <c>ConcurrentHashMap</c> is normally preferable to a synchronized
 <c>HashMap</c>, and a <c>ConcurrentSkipListMap</c> is normally
 preferable to a synchronized <c>TreeMap</c>.
 A <c>CopyOnWriteArrayList</c> is preferable to a synchronized
 <c>ArrayList</c> when the expected number of reads and traversals
 greatly outnumber the number of updates to a list.

 </para><para tool="javadoc-to-mdoc">The "Concurrent" prefix used with some classes in this package
 is a shorthand indicating several differences from similar
 "synchronized" classes.  For example <c>java.util.Hashtable</c> and
 <c>Collections.synchronizedMap(new HashMap())</c> are
 synchronized.  But <c><see cref="T:Java.Util.Concurrent.ConcurrentHashMap" /></c> is "concurrent".  A
 concurrent collection is thread-safe, but not governed by a
 single exclusion lock.  In the particular case of
 ConcurrentHashMap, it safely permits any number of
 concurrent reads as well as a tunable number of concurrent
 writes.  "Synchronized" classes can be useful when you need
 to prevent all access to a collection via a single lock, at
 the expense of poorer scalability.  In other cases in which
 multiple threads are expected to access a common collection,
 "concurrent" versions are normally preferable.  And
 unsynchronized collections are preferable when either
 collections are unshared, or are accessible only when
 holding other locks.

 </para><para tool="javadoc-to-mdoc">Most concurrent Collection implementations (including most
 Queues) also differ from the usual java.util conventions in that
 their Iterators provide <i>weakly consistent</i> rather than
 fast-fail traversal.  A weakly consistent iterator is thread-safe,
 but does not necessarily freeze the collection while iterating, so
 it may (or may not) reflect any updates since the iterator was
 created.

 <format type="text/html"><h2 id="MemoryVisibility">Memory Consistency Properties</h2></format> defines the
 <format type="text/html"><i>happens-before</i></format> relation on memory operations such as reads and
 writes of shared variables.  The results of a write by one thread are
 guaranteed to be visible to a read by another thread only if the write
 operation <format type="text/html"><i>happens-before</i></format> the read operation.  The
 <c>synchronized</c> and <c>volatile</c> constructs, as well as the
 <c>Thread.start()</c> and <c>Thread.join()</c> methods, can form
 <format type="text/html"><i>happens-before</i></format> relationships.  In particular:

 <list type="bullet"><item><term>Each action in a thread <format type="text/html"><i>happens-before</i></format> every action in that
   thread that comes later in the program's order.

   </term></item><item><term>An unlock (<c>synchronized</c> block or method exit) of a
   monitor <format type="text/html"><i>happens-before</i></format> every subsequent lock (<c>synchronized</c>
   block or method entry) of that same monitor.  And because
   the <format type="text/html"><i>happens-before</i></format> relation is transitive, all actions
   of a thread prior to unlocking <format type="text/html"><i>happen-before</i></format> all actions
   subsequent to any thread locking that monitor.

   </term></item><item><term>A write to a <c>volatile</c> field <format type="text/html"><i>happens-before</i></format> every
   subsequent read of that same field.  Writes and reads of
   <c>volatile</c> fields have similar memory consistency effects
   as entering and exiting monitors, but do <i>not</i> entail
   mutual exclusion locking.

   </term></item><item><term>A call to <c>start</c> on a thread <format type="text/html"><i>happens-before</i></format> any
   action in the started thread.

   </term></item><item><term>All actions in a thread <format type="text/html"><i>happen-before</i></format> any other thread
   successfully returns from a <c>join</c> on that thread.

 </term></item></list>


 The methods of all classes in <c>java.util.concurrent</c> and its
 subpackages extend these guarantees to higher-level
 synchronization.  In particular:

 <list type="bullet"><item><term>Actions in a thread prior to placing an object into any concurrent
   collection <format type="text/html"><i>happen-before</i></format> actions subsequent to the access or
   removal of that element from the collection in another thread.

   </term></item><item><term>Actions in a thread prior to the submission of a <c>Runnable</c>
   to an <c>Executor</c><format type="text/html"><i>happen-before</i></format> its execution begins.
   Similarly for <c>Callables</c> submitted to an <c>ExecutorService</c>.

   </term></item><item><term>Actions taken by the asynchronous computation represented by a
   <c>Future</c><format type="text/html"><i>happen-before</i></format> actions subsequent to the
   retrieval of the result via <c>Future.get()</c> in another thread.

   </term></item><item><term>Actions prior to "releasing" synchronizer methods such as
   <c>Lock.unlock</c>, <c>Semaphore.release</c>, and
   <c>CountDownLatch.countDown</c><format type="text/html"><i>happen-before</i></format> actions
   subsequent to a successful "acquiring" method such as
   <c>Lock.lock</c>, <c>Semaphore.acquire</c>,
   <c>Condition.await</c>, and <c>CountDownLatch.await</c> on the
   same synchronizer object in another thread.

   </term></item><item><term>For each pair of threads that successfully exchange objects via
   an <c>Exchanger</c>, actions prior to the <c>exchange()</c>
   in each thread <format type="text/html"><i>happen-before</i></format> those subsequent to the
   corresponding <c>exchange()</c> in another thread.

   </term></item><item><term>Actions prior to calling <c>CyclicBarrier.await</c><format type="text/html"><i>happen-before</i></format> actions performed by the barrier action, and
   actions performed by the barrier action <format type="text/html"><i>happen-before</i></format> actions
   subsequent to a successful return from the corresponding <c>await</c>
   in other threads.

 </term></item></list></para></remarks>
  </Docs>
</Namespace>
